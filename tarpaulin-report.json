{"files":[{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","animation","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::app::update::Update;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::signal::Signal;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::Widget;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::animator::Animator;\r\nuse maycoon::widgets::text::Text;\r\nuse std::time::Duration;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(context: AppContext, _: Self::State) -> impl Widget {\r\n        let font_size = context.use_state(0.0);\r\n\r\n        Animator::new(\r\n            Duration::from_millis(2000),\r\n            Text::new(\"Hello World!\".to_string()).with_font_size(font_size.maybe()),\r\n            move |_, f| {\r\n                font_size.set(f * 30.0);\r\n\r\n                Update::DRAW\r\n            },\r\n        )\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","canvas","src","main.rs"],"content":"use maycoon::color::Brush;\r\nuse maycoon::color::color::palette;\r\nuse maycoon::color::kurbo::{Circle, Point, Stroke};\r\nuse maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::Widget;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::canvas::Canvas;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(_: AppContext, _: Self::State) -> impl Widget {\r\n        Canvas::new(|scene, _| {\r\n            scene.draw_circle(\r\n                &Brush::Solid(palette::css::GREEN),\r\n                None,\r\n                Some(&Stroke::new(10.0)),\r\n                &Circle::new(Point::new(100.0, 100.0), 50.0),\r\n            );\r\n        })\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","checkbox","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::layout::{AlignItems, Dimension, FlexDirection, LayoutStyle};\r\nuse maycoon::core::reference::Ref;\r\nuse maycoon::core::signal::Signal;\r\nuse maycoon::core::signal::state::StateSignal;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon::math::Vector2;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::checkbox::Checkbox;\r\nuse maycoon::widgets::container::Container;\r\nuse maycoon::widgets::text::Text;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(context: AppContext, _: Self::State) -> impl Widget {\r\n        let checked = context.use_signal(StateSignal::new(false));\r\n\r\n        Container::new(vec![\r\n            {\r\n                let checked = checked.clone();\r\n\r\n                Box::new(Checkbox::new(checked.maybe()))\r\n            },\r\n            {\r\n                let checked = checked.clone();\r\n\r\n                Box::new(Text::new(checked.map(|val| Ref::Owned(val.to_string()))))\r\n            },\r\n        ])\r\n        .with_layout_style(LayoutStyle {\r\n            size: Vector2::<Dimension>::new(Dimension::percent(1.0), Dimension::percent(1.0)),\r\n            flex_direction: FlexDirection::Column,\r\n            align_items: Some(AlignItems::Center),\r\n            ..Default::default()\r\n        })\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","component","src","counter.rs"],"content":"use maycoon::core::app::context::AppContext;\r\nuse maycoon::core::app::update::Update;\r\nuse maycoon::core::component::{Component, Composed};\r\nuse maycoon::core::layout::LayoutStyle;\r\nuse maycoon::core::reference::Ref;\r\nuse maycoon::core::signal::eval::EvalSignal;\r\nuse maycoon::core::signal::state::StateSignal;\r\nuse maycoon::core::signal::{MaybeSignal, Signal};\r\nuse maycoon::core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon::theme::id::WidgetId;\r\nuse maycoon::widgets::button::Button;\r\nuse maycoon::widgets::container::Container;\r\nuse maycoon::widgets::text::Text;\r\n\r\npub struct Counter {\r\n    counter: StateSignal<i32>,\r\n    layout: MaybeSignal<LayoutStyle>,\r\n}\r\n\r\nimpl Counter {\r\n    pub fn new(counter: StateSignal<i32>) -> Composed<Self> {\r\n        Counter {\r\n            counter,\r\n            layout: LayoutStyle::default().into(),\r\n        }\r\n        .compose()\r\n    }\r\n}\r\n\r\nimpl Component for Counter {\r\n    fn build(&self, context: AppContext) -> impl Widget + 'static {\r\n        let counter = self.counter.clone();\r\n\r\n        Container::new(vec![\r\n            {\r\n                let counter = counter.clone();\r\n\r\n                Box::new(\r\n                    Button::new(Text::new(\"Increase\".to_string())).with_on_pressed(\r\n                        EvalSignal::new(move || {\r\n                            counter.mutate(|i| *i += 1);\r\n                            Update::DRAW\r\n                        })\r\n                        .hook(&context)\r\n                        .maybe(),\r\n                    ),\r\n                )\r\n            },\r\n            {\r\n                let counter = counter.clone();\r\n\r\n                Box::new(\r\n                    Button::new(Text::new(\"Decrease\".to_string())).with_on_pressed(\r\n                        EvalSignal::new(move || {\r\n                            counter.mutate(|i| *i -= 1);\r\n                            Update::DRAW\r\n                        })\r\n                        .hook(&context)\r\n                        .maybe(),\r\n                    ),\r\n                )\r\n            },\r\n            Box::new(Text::new(counter.map(|i| Ref::Owned(i.to_string())))),\r\n        ])\r\n        .with_layout_style(self.layout.get().clone())\r\n    }\r\n\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"my-example\", \"Counter\")\r\n    }\r\n}\r\n\r\nimpl WidgetLayoutExt for Counter {\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.layout = layout_style.into();\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","component","src","main.rs"],"content":"use crate::counter::Counter;\r\nuse maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::layout::{AlignItems, Dimension, FlexDirection, LayoutStyle};\r\nuse maycoon::core::signal::state::StateSignal;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon::math::Vector2;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\n\r\nmod counter;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(context: AppContext, _: Self::State) -> impl Widget {\r\n        let counter = context.use_signal(StateSignal::new(0));\r\n\r\n        Counter::new(counter).with_layout_style(LayoutStyle {\r\n            size: Vector2::<Dimension>::new(Dimension::percent(1.0), Dimension::percent(1.0)),\r\n            flex_direction: FlexDirection::Column,\r\n            align_items: Some(AlignItems::Center),\r\n            ..Default::default()\r\n        })\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","counter","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::app::update::Update;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::layout::{AlignItems, Dimension, FlexDirection, LayoutStyle};\r\nuse maycoon::core::reference::Ref;\r\nuse maycoon::core::signal::Signal;\r\nuse maycoon::core::signal::eval::EvalSignal;\r\nuse maycoon::core::signal::state::StateSignal;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon::math::Vector2;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::button::Button;\r\nuse maycoon::widgets::container::Container;\r\nuse maycoon::widgets::text::Text;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(context: AppContext, _: Self::State) -> impl Widget {\r\n        let counter = context.use_signal(StateSignal::new(0));\r\n\r\n        Container::new(vec![\r\n            {\r\n                let counter = counter.clone();\r\n\r\n                Box::new(\r\n                    Button::new(Text::new(\"Increase\".to_string())).with_on_pressed(\r\n                        EvalSignal::new(move || {\r\n                            counter.mutate(|c| *c += 1);\r\n\r\n                            Update::DRAW\r\n                        })\r\n                        .hook(&context)\r\n                        .maybe(),\r\n                    ),\r\n                )\r\n            },\r\n            {\r\n                let counter = counter.clone();\r\n\r\n                Box::new(\r\n                    Button::new(Text::new(\"Decrease\".to_string())).with_on_pressed(\r\n                        EvalSignal::new(move || {\r\n                            counter.mutate(|c| *c -= 1);\r\n\r\n                            Update::DRAW\r\n                        })\r\n                        .hook(&context)\r\n                        .maybe(),\r\n                    ),\r\n                )\r\n            },\r\n            Box::new(Text::new(counter.map(|i| Ref::Owned(i.to_string())))),\r\n        ])\r\n        .with_layout_style(LayoutStyle {\r\n            size: Vector2::<Dimension>::new(Dimension::percent(1.0), Dimension::percent(1.0)),\r\n            flex_direction: FlexDirection::Column,\r\n            align_items: Some(AlignItems::Center),\r\n            ..Default::default()\r\n        })\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","fetcher","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::app::update::Update;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::Widget;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::fetcher::WidgetFetcher;\r\nuse maycoon::widgets::text::Text;\r\nuse serde::Deserialize;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(_: AppContext, _: Self::State) -> impl Widget {\r\n        WidgetFetcher::new(\r\n            Box::pin(get_random_quote()),\r\n            |data| {\r\n                if let Some(data) = data {\r\n                    Text::new(format!(\" \\\"{}\\\" \\n - {}\", data.quote, data.author))\r\n                } else {\r\n                    Text::new(\" Loading Quote...\".to_string())\r\n                }\r\n            },\r\n            Update::DRAW,\r\n        )\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n\r\n#[derive(Deserialize)]\r\nstruct Quote {\r\n    quote: String,\r\n    author: String,\r\n}\r\n\r\nasync fn get_random_quote() -> Quote {\r\n    surf::get(\"https://dummyjson.com/quotes/random\")\r\n        .await\r\n        .expect(\"Failed to fetch quote\")\r\n        .body_json::<Quote>()\r\n        .await\r\n        .expect(\"Failed to parse quote\")\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","gesture_detector","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::app::update::Update;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::signal::Signal;\r\nuse maycoon::core::signal::eval::EvalSignal;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::Widget;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::gesture_detector::GestureDetector;\r\nuse maycoon::widgets::text::Text;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(context: AppContext, _: Self::State) -> impl Widget {\r\n        GestureDetector::new(Text::new(\"Gesture Detector\".to_string()))\r\n            .with_on_hover(\r\n                EvalSignal::new(move || {\r\n                    println!(\"Hovered\");\r\n                    Update::DRAW\r\n                })\r\n                .hook(&context)\r\n                .maybe(),\r\n            )\r\n            .with_on_release(\r\n                EvalSignal::new(move || {\r\n                    println!(\"Release\");\r\n                    Update::DRAW\r\n                })\r\n                .hook(&context)\r\n                .maybe(),\r\n            )\r\n            .with_on_press(\r\n                EvalSignal::new(move || {\r\n                    println!(\"Press\");\r\n                    Update::DRAW\r\n                })\r\n                .hook(&context)\r\n                .maybe(),\r\n            )\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","hello_world","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::Widget;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::text::Text;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(_: AppContext, _: Self::State) -> impl Widget {\r\n        Text::new(\"Hello World\".to_string())\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","icon","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::Widget;\r\nuse maycoon::macros::svg_icon;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::icon::Icon;\r\nuse maycoon::widgets::icon::svg::SvgIcon;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(_: AppContext, _: Self::State) -> impl Widget {\r\n        let icon: SvgIcon = svg_icon!(\"./assets/logo.svg\");\r\n\r\n        Icon::new(icon)\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","image","src","main.rs"],"content":"use maycoon::color::{Blob, ImageAlphaType, ImageData, ImageFormat};\r\nuse maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::Widget;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::image::Image;\r\n\r\nconst IMAGE_DATA: &[u8] = include_bytes!(\"../pelican.jpg\");\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(_: AppContext, _: Self::State) -> impl Widget {\r\n        Image::new(ImageData {\r\n            data: Blob::from(\r\n                image::load_from_memory(IMAGE_DATA)\r\n                    .unwrap()\r\n                    .into_rgba8()\r\n                    .to_vec(),\r\n            ),\r\n            format: ImageFormat::Rgba8,\r\n            alpha_type: ImageAlphaType::Alpha,\r\n            width: 427,\r\n            height: 640,\r\n        })\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","plugin","src","main.rs"],"content":"use crate::plugin::MyPlugin;\r\nuse maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::plugin::PluginManager;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::Widget;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::text::Text;\r\n\r\npub mod plugin;\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(_: AppContext, _: Self::State) -> impl Widget {\r\n        Text::new(\"Drop a file!\".to_string())\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n\r\n    fn plugins(&self) -> PluginManager<Self::Theme, Self::Graphics> {\r\n        PluginManager::new().register(MyPlugin)\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","plugin","src","plugin.rs"],"content":"use maycoon::core::app::info::AppInfo;\r\nuse maycoon::core::app::update::UpdateManager;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::layout::{NodeId, TaffyTree};\r\nuse maycoon::core::plugin::{Plugin, PluginManager};\r\nuse maycoon::core::vgi::VectorGraphicsInterface;\r\nuse maycoon::core::window::{ActiveEventLoop, Window, WindowEvent};\r\nuse maycoon::theme::theme::Theme;\r\nuse std::sync::Arc;\r\n\r\npub struct MyPlugin;\r\n\r\nimpl<T: Theme, V: VectorGraphicsInterface> Plugin<T, V> for MyPlugin {\r\n    fn name(&self) -> &'static str {\r\n        \"my_plugin\"\r\n    }\r\n\r\n    fn on_register(&mut self, _manager: &mut PluginManager<T, V>) {\r\n        println!(\"Hello World!\");\r\n    }\r\n\r\n    fn on_unregister(&mut self, _manager: &mut PluginManager<T, V>) {\r\n        println!(\"Bye World!\");\r\n    }\r\n\r\n    fn on_window_event(\r\n        &mut self,\r\n        event: &mut WindowEvent,\r\n        _config: &mut MayConfig<T, V>,\r\n        _window: &Arc<Window>,\r\n        _scene: &mut V::Scene,\r\n        _taffy: &mut TaffyTree,\r\n        _window_node: NodeId,\r\n        _info: &mut AppInfo,\r\n        _update: &UpdateManager,\r\n        _event_loop: &ActiveEventLoop,\r\n    ) {\r\n        if let WindowEvent::DroppedFile(path) = event {\r\n            println!(\"Dropped file: {}\", path.to_string_lossy());\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","slider","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::layout::{AlignItems, Dimension, FlexDirection, LayoutStyle};\r\nuse maycoon::core::reference::Ref;\r\nuse maycoon::core::signal::Signal;\r\nuse maycoon::core::signal::state::StateSignal;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon::math::Vector2;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::container::Container;\r\nuse maycoon::widgets::slider::Slider;\r\nuse maycoon::widgets::text::Text;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(context: AppContext, _: Self::State) -> impl Widget {\r\n        let value = context.use_signal(StateSignal::new(0.0f32));\r\n\r\n        Container::new(vec![\r\n            Box::new(Slider::new(value.maybe())),\r\n            Box::new(Text::new(value.map(|i| Ref::Owned(i.to_string())))),\r\n        ])\r\n        .with_layout_style(LayoutStyle {\r\n            size: Vector2::<Dimension>::new(Dimension::percent(1.0), Dimension::percent(1.0)),\r\n            flex_direction: FlexDirection::Column,\r\n            align_items: Some(AlignItems::Center),\r\n            ..Default::default()\r\n        })\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","switch","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::layout::{AlignItems, Dimension, FlexDirection, LayoutStyle};\r\nuse maycoon::core::reference::Ref;\r\nuse maycoon::core::signal::Signal;\r\nuse maycoon::core::signal::state::StateSignal;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon::math::Vector2;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::container::Container;\r\nuse maycoon::widgets::switch::Switch;\r\nuse maycoon::widgets::text::Text;\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(context: AppContext, _: Self::State) -> impl Widget {\r\n        let checked = context.use_signal(StateSignal::new(false));\r\n\r\n        Container::new(vec![\r\n            {\r\n                let checked = checked.clone();\r\n\r\n                Box::new(Switch::new(checked.maybe()))\r\n            },\r\n            {\r\n                let checked = checked.clone();\r\n\r\n                Box::new(Text::new(checked.map(|val| Ref::Owned(val.to_string()))))\r\n            },\r\n        ])\r\n        .with_layout_style(LayoutStyle {\r\n            size: Vector2::<Dimension>::new(Dimension::percent(1.0), Dimension::percent(1.0)),\r\n            flex_direction: FlexDirection::Column,\r\n            align_items: Some(AlignItems::Center),\r\n            ..Default::default()\r\n        })\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n\r\nfn main() {\r\n    MyApp.run(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","examples","tracing-flame","src","main.rs"],"content":"use maycoon::core::app::Application;\r\nuse maycoon::core::app::context::AppContext;\r\nuse maycoon::core::config::MayConfig;\r\nuse maycoon::core::vgi::DefaultGraphics;\r\nuse maycoon::core::widget::Widget;\r\nuse maycoon::theme::theme::celeste::CelesteTheme;\r\nuse maycoon::widgets::text::Text;\r\nuse tracing_flame::FlameLayer;\r\nuse tracing_subscriber::filter::{FilterFn, LevelFilter};\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{Layer, fmt};\r\n\r\nconst FILTER_TARGETS: [&str; 3] = [\"wgpu\", \"naga\", \"winit\"];\r\n\r\nfn main() {\r\n    let filter = FilterFn::new(|md| {\r\n        for target in FILTER_TARGETS {\r\n            if md.target().starts_with(target) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        true\r\n    });\r\n\r\n    let (flame, guard) = FlameLayer::with_file(\"tracing.folded\").unwrap();\r\n\r\n    tracing_subscriber::registry()\r\n        .with(\r\n            fmt::layer()\r\n                .compact()\r\n                .with_filter(filter.clone())\r\n                .with_filter(LevelFilter::DEBUG),\r\n        )\r\n        .with(flame.with_file_and_line(false).with_filter(filter))\r\n        .init();\r\n\r\n    MyApp.run(());\r\n\r\n    guard.flush().unwrap();\r\n}\r\n\r\nstruct MyApp;\r\n\r\nimpl Application for MyApp {\r\n    type Theme = CelesteTheme;\r\n    type Graphics = DefaultGraphics;\r\n    type State = ();\r\n\r\n    fn build(_: AppContext, _: Self::State) -> impl Widget {\r\n        Text::new(\"Hello World!\".to_string())\r\n    }\r\n\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics> {\r\n        MayConfig::default()\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","build.rs"],"content":"fn main() {\r\n    if cfg!(not(any(feature = \"tokio-runner\", feature = \"dummy-runner\"))) {\r\n        panic!(\r\n            \"No valid task runner feature selected. Please select a `-runner` feature (e.g. `tokio-runner`).\"\r\n        );\r\n    }\r\n\r\n    cfg_aliases::cfg_aliases! {\r\n        web: { target_arch = \"wasm32\" },\r\n        native: { not(target_arch = \"wasm32\") },\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","app","context.rs"],"content":"use crate::app::diagnostics::Diagnostics;\r\nuse crate::app::update::{Update, UpdateManager};\r\nuse crate::signal::Signal;\r\nuse crate::signal::eval::EvalSignal;\r\nuse crate::signal::fixed::FixedSignal;\r\nuse crate::signal::memoized::MemoizedSignal;\r\nuse crate::signal::state::StateSignal;\r\n\r\n/// The application context for managing the application lifecycle.\r\n#[derive(Clone)]\r\npub struct AppContext {\r\n    update: UpdateManager,\r\n    diagnostics: Diagnostics,\r\n}\r\n\r\nimpl AppContext {\r\n    /// Create a new application context using the given [UpdateManager].\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip_all)]\r\n    pub fn new(update: UpdateManager, diagnostics: Diagnostics) -> Self {\r\n        Self {\r\n            update,\r\n            diagnostics,\r\n        }\r\n    }\r\n\r\n    /// Get the [Diagnostics] of the application.\r\n    #[inline(always)]\r\n    pub const fn diagnostics(&self) -> Diagnostics {\r\n        self.diagnostics\r\n    }\r\n\r\n    /// Get the [UpdateManager] of the application.\r\n    #[inline(always)]\r\n    pub fn update(&self) -> UpdateManager {\r\n        self.update.clone()\r\n    }\r\n\r\n    /// Make the application exit by setting [Update::EXIT].\r\n    #[inline(always)]\r\n    pub fn exit(&self) {\r\n        self.update.insert(Update::EXIT);\r\n    }\r\n\r\n    /// Hook the given [Signal] to the [UpdateManager] of this application and return it.\r\n    ///\r\n    /// This makes the signal reactive, so it will notify the renderer when the inner value changes.\r\n    #[inline(always)]\r\n    pub fn use_signal<T: 'static, S: Signal<T>>(&self, signal: S) -> S {\r\n        let update = self.update();\r\n\r\n        signal.listen(Box::new(move |_| update.insert(Update::EVAL)))\r\n    }\r\n\r\n    /// Shortcut for creating and hooking a [StateSignal] into the application lifecycle.\r\n    #[inline(always)]\r\n    pub fn use_state<T: 'static>(&self, value: T) -> StateSignal<T> {\r\n        self.use_signal(StateSignal::new(value))\r\n    }\r\n\r\n    /// Shortcut for creating and hooking a [MemoizedSignal] into the application lifecycle.\r\n    #[inline(always)]\r\n    pub fn use_memoized<T: 'static>(&self, value: impl Fn() -> T + 'static) -> MemoizedSignal<T> {\r\n        self.use_signal(MemoizedSignal::new(value))\r\n    }\r\n\r\n    /// Shortcut for creating and hooking a [FixedSignal] into the application lifecycle.\r\n    #[inline(always)]\r\n    pub fn use_fixed<T: 'static>(&self, value: T) -> FixedSignal<T> {\r\n        self.use_signal(FixedSignal::new(value))\r\n    }\r\n\r\n    /// Shortcut for creating and hooking an [EvalSignal] into the application lifecycle.\r\n    #[inline(always)]\r\n    pub fn use_eval<T: 'static>(&self, eval: impl Fn() -> T + 'static) -> EvalSignal<T> {\r\n        self.use_signal(EvalSignal::new(eval))\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","app","diagnostics.rs"],"content":"use crate::platform::time::Instant;\r\n\r\n/// Contains diagnostics data for the application.\r\n#[derive(Debug, Copy, Clone, PartialEq)]\r\npub struct Diagnostics {\r\n    /// The last time the diagnostics got updated. Resets every second.\r\n    pub last_tick: Instant,\r\n\r\n    /// The updates since the last second. Use `updates_per_sec` for the average updates per second.\r\n    pub updates: usize,\r\n    /// The average updates per second.\r\n    pub updates_per_sec: usize,\r\n\r\n    /// The frames since the last second. Use `frames_per_sec` for the average frames per second.\r\n    pub frames: usize,\r\n    /// The average frames per second.\r\n    pub frames_per_sec: usize,\r\n\r\n    /// Whether this is the first run of the application.\r\n    pub first_run: bool,\r\n}\r\n\r\nimpl Diagnostics {\r\n    /// Ticks the diagnostics.\r\n    ///\r\n    /// This computes frames and updates per second\r\n    /// and is called every frame by the event loop.\r\n    #[inline(always)]\r\n    pub fn tick(&mut self) {\r\n        if self.last_tick.elapsed().as_secs() >= 1 {\r\n            self.last_tick = Instant::now();\r\n\r\n            self.frames_per_sec = (self.frames_per_sec + self.frames) / 2;\r\n            self.updates_per_sec = (self.updates_per_sec + self.updates) / 2;\r\n\r\n            self.updates = 0;\r\n            self.frames = 0;\r\n        }\r\n    }\r\n\r\n    /// Increases the update count.\r\n    #[inline(always)]\r\n    pub fn do_update(&mut self) {\r\n        self.updates += 1;\r\n    }\r\n\r\n    /// Increases the frame count.\r\n    #[inline(always)]\r\n    pub fn do_frame(&mut self) {\r\n        self.frames += 1;\r\n    }\r\n}\r\n\r\nimpl Default for Diagnostics {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self {\r\n            last_tick: Instant::now(),\r\n            updates: 0,\r\n            updates_per_sec: 0,\r\n            frames: 0,\r\n            frames_per_sec: 0,\r\n            first_run: true,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","app","font_ctx.rs"],"content":"use peniko::FontData;\r\nuse rpds::HashTrieMap;\r\n\r\n/// A font manager for maycoon applications.\r\n///\r\n/// Can be used to load and access in-memory fonts or by system source.\r\n///\r\n/// If the default `include-noto-sans` feature is enabled, the default font is set to [Noto Sans](https://fonts.google.com/specimen/Noto+Sans).\r\n#[derive(Clone, Debug)]\r\npub struct FontContext {\r\n    default: String,\r\n    fonts: HashTrieMap<String, FontData>,\r\n}\r\n\r\nimpl FontContext {\r\n    /// Create a new font context with the given default font name.\r\n    ///\r\n    /// Make sure to load the default font via [FontContext::load],\r\n    /// before passing this context to the application runner.\r\n    #[inline(always)]\r\n    pub fn new(default: impl ToString) -> Self {\r\n        Self {\r\n            default: default.to_string(),\r\n            fonts: HashTrieMap::new(),\r\n        }\r\n    }\r\n\r\n    /// Loads a font with a custom name into the font context and return itself.\r\n    ///\r\n    /// If the font with the same name already exists, [None] is returned.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip_all, fields(name = name.to_string()))]\r\n    pub fn load(self, name: impl ToString, font: FontData) -> Option<Self> {\r\n        let name = name.to_string();\r\n\r\n        tracing::trace!(\"loading font named {}\", name);\r\n\r\n        if self.fonts.contains_key(&name) {\r\n            return None;\r\n        }\r\n\r\n        Some(Self {\r\n            fonts: self.fonts.insert(name, font),\r\n            default: self.default,\r\n        })\r\n    }\r\n\r\n    /// Set the default font.\r\n    ///\r\n    /// **NOTE:** The font must be loaded before usage with [FontContext::load].\r\n    #[inline(always)]\r\n    pub fn set_default_font(&mut self, name: impl ToString) {\r\n        self.default = name.to_string();\r\n    }\r\n\r\n    /// Get a font by a specified name. Returns [None] if the font could not be found.\r\n    #[inline(always)]\r\n    pub fn get(&self, name: impl ToString) -> Option<FontData> {\r\n        self.fonts.get(&name.to_string()).cloned()\r\n    }\r\n\r\n    /// Removes a font by the given name and returns it or [None] if the font could not be found.\r\n    #[inline(always)]\r\n    pub fn remove(self, name: impl AsRef<str>) -> Option<Self> {\r\n        if self.fonts.contains_key(name.as_ref()) {\r\n            return None;\r\n        }\r\n\r\n        Some(Self {\r\n            fonts: self.fonts.remove(name.as_ref()),\r\n            default: self.default,\r\n        })\r\n    }\r\n\r\n    /// Returns the default font. [Roboto](https://fonts.google.com/specimen/Roboto) by default.\r\n    #[inline(always)]\r\n    pub fn default_font(&self) -> &FontData {\r\n        self.fonts\r\n            .get(&self.default)\r\n            .expect(\"Default font not found. Please load one via `FontContext::load`.\")\r\n    }\r\n}\r\n\r\nimpl Default for FontContext {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        tracing::debug!(\"loading noto sans system font\");\r\n\r\n        FontContext::new(\"Noto Sans\".to_string())\r\n            .load(\r\n                \"Noto Sans\",\r\n                FontData::new(\r\n                    peniko::Blob::new(std::sync::Arc::new(crate::DEFAULT_FONT)),\r\n                    0,\r\n                ),\r\n            )\r\n            .unwrap()\r\n    }\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","app","handler.rs"],"content":"use nalgebra::Vector2;\r\nuse std::sync::Arc;\r\nuse taffy::{\r\n    AvailableSpace, Dimension, NodeId, PrintTree, Size, Style, TaffyResult, TaffyTree,\r\n    TraversePartialTree,\r\n};\r\nuse winit::application::ApplicationHandler;\r\nuse winit::event::WindowEvent;\r\nuse winit::event_loop::ActiveEventLoop;\r\nuse winit::window::{Window, WindowAttributes, WindowId};\r\n\r\nuse crate::app::context::AppContext;\r\nuse crate::app::font_ctx::FontContext;\r\nuse crate::app::info::AppInfo;\r\nuse crate::app::update::{Update, UpdateManager};\r\nuse crate::config::MayConfig;\r\nuse crate::layout::{LayoutNode, StyleNode};\r\nuse crate::plugin::PluginManager;\r\nuse crate::vgi::{Scene, VectorGraphicsInterface};\r\nuse crate::widget::Widget;\r\nuse maycoon_theme::theme::Theme;\r\n\r\n/// The core application handler. You should use [MayApp](crate::app::MayApp) instead for running applications.\r\npub struct AppHandler<T, W, S, F, V>\r\nwhere\r\n    T: Theme,\r\n    W: Widget,\r\n    F: Fn(AppContext, S) -> W,\r\n    V: VectorGraphicsInterface,\r\n{\r\n    config: MayConfig<T, V>,\r\n    attrs: WindowAttributes,\r\n    window: Option<Arc<Window>>,\r\n    scene: V::Scene,\r\n    taffy: TaffyTree,\r\n    window_node: NodeId,\r\n    builder: F,\r\n    state: Option<S>,\r\n    widget: Option<W>,\r\n    info: AppInfo,\r\n    update: UpdateManager,\r\n    plugins: PluginManager<T, V>,\r\n    graphics: V,\r\n}\r\n\r\nimpl<T, W, S, F, V> AppHandler<T, W, S, F, V>\r\nwhere\r\n    T: Theme,\r\n    W: Widget,\r\n    F: Fn(AppContext, S) -> W,\r\n    V: VectorGraphicsInterface,\r\n{\r\n    /// Create a new handler with given window attributes, config, widget and state.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip_all)]\r\n    pub fn new(\r\n        attrs: WindowAttributes,\r\n        config: MayConfig<T, V>,\r\n        builder: F,\r\n        state: S,\r\n        font_context: FontContext,\r\n        update: UpdateManager,\r\n        plugins: PluginManager<T, V>,\r\n    ) -> Self {\r\n        tracing::trace!(\"creating taffy tree\");\r\n        let mut taffy = TaffyTree::with_capacity(16);\r\n\r\n        // gets configured on resume\r\n        let window_node = taffy\r\n            .new_leaf(Style::default())\r\n            .expect(\"Failed to create window node\");\r\n\r\n        let size = config.window.size;\r\n\r\n        let graphics = config.graphics.clone();\r\n\r\n        Self {\r\n            attrs,\r\n            window: None,\r\n            config,\r\n            scene: Scene::new(),\r\n            taffy,\r\n            widget: None,\r\n            info: AppInfo {\r\n                font_context,\r\n                size,\r\n                ..Default::default()\r\n            },\r\n            window_node,\r\n            builder,\r\n            state: Some(state),\r\n            update,\r\n            plugins,\r\n            graphics: V::new(graphics).expect(\"Failed to create vector graphics interface\"),\r\n        }\r\n    }\r\n\r\n    /// Get the application context.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip_all)]\r\n    pub fn context(&self) -> AppContext {\r\n        AppContext::new(self.update.clone(), self.info.diagnostics)\r\n    }\r\n\r\n    /// Add the parent node and its children to the layout tree.\r\n    #[tracing::instrument(level = \"trace\", skip(self, style))]\r\n    fn layout_widget(&mut self, parent: NodeId, style: &StyleNode) -> TaffyResult<()> {\r\n        let node = self.taffy.new_leaf(style.style.clone().into())?;\r\n\r\n        self.taffy.add_child(parent, node)?;\r\n\r\n        for child in &style.children {\r\n            self.layout_widget(node, child)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Compute the layout of the root node and its children.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip(self))]\r\n    fn compute_layout(&mut self) -> TaffyResult<()> {\r\n        self.taffy.compute_layout(\r\n            self.window_node,\r\n            Size::<AvailableSpace> {\r\n                width: AvailableSpace::Definite(\r\n                    self.window.as_ref().unwrap().inner_size().width as f32,\r\n                ),\r\n                height: AvailableSpace::Definite(\r\n                    self.window.as_ref().unwrap().inner_size().height as f32,\r\n                ),\r\n            },\r\n        )?;\r\n        Ok(())\r\n    }\r\n\r\n    /// Collect the computed layout of the given node and its children. Make sure to call [AppHandler::compute_layout] before, to not get dirty results.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip(self, style))]\r\n    fn collect_layout(&mut self, node: NodeId, style: &StyleNode) -> TaffyResult<LayoutNode> {\r\n        tracing::trace!(\"collecting node layout {node:?}\");\r\n\r\n        let mut children = Vec::with_capacity(style.children.capacity());\r\n\r\n        for (i, style) in style.children.iter().enumerate() {\r\n            let child = self.taffy.child_at_index(node, i)?;\r\n\r\n            tracing::trace!(\"collecting layout of child {child:?}\");\r\n\r\n            children.push(self.collect_layout(child, style)?);\r\n        }\r\n\r\n        Ok(LayoutNode {\r\n            layout: self.taffy.get_final_layout(node),\r\n            children,\r\n        })\r\n    }\r\n\r\n    /// Request a window redraw.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip(self))]\r\n    fn request_redraw(&self) {\r\n        tracing::trace!(\"requesting redraw\");\r\n        self.window.as_ref().unwrap().request_redraw();\r\n    }\r\n\r\n    /// Render the application via the vector graphics interface.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip(self))]\r\n    fn render(\r\n        &mut self,\r\n        window: Arc<Window>,\r\n        event_loop: &ActiveEventLoop,\r\n    ) -> Result<(), V::Error> {\r\n        tracing::trace!(\"rendering via vector graphics interface\");\r\n        self.graphics.render(\r\n            window,\r\n            event_loop,\r\n            &self.scene,\r\n            self.config.theme.window_background(),\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Update the app and process events.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip_all)]\r\n    fn update(&mut self, event_loop: &ActiveEventLoop) {\r\n        // tick the task runner\r\n        crate::tasks::runner().tick();\r\n\r\n        // update plugins\r\n        tracing::trace!(\"updating plugins\");\r\n        self.plugins.run(|pl| {\r\n            pl.on_update(\r\n                &mut self.config,\r\n                self.window.as_ref().expect(\"Window not initialized\"),\r\n                &mut self.scene,\r\n                &mut self.taffy,\r\n                self.window_node,\r\n                &mut self.info,\r\n                &self.update,\r\n                event_loop,\r\n            )\r\n        });\r\n\r\n        // completely layout widgets if taffy is not set up yet (e.g. during first update)\r\n        if self.taffy.child_count(self.window_node) == 0 {\r\n            tracing::trace_span!(\"complete layout\").in_scope(|| {\r\n                let style = self.widget.as_ref().unwrap().layout_style();\r\n\r\n                self.layout_widget(self.window_node, &style)\r\n                    .expect(\"Failed to layout window\");\r\n\r\n                self.compute_layout().expect(\"Failed to compute layout\");\r\n\r\n                self.update.insert(Update::FORCE);\r\n            });\r\n        }\r\n\r\n        let style = self.widget.as_ref().unwrap().layout_style();\r\n\r\n        let mut layout_node = self\r\n            .collect_layout(\r\n                self.taffy.child_at_index(self.window_node, 0).unwrap(),\r\n                &style,\r\n            )\r\n            .expect(\"Failed to collect layout\");\r\n\r\n        // update call to check if app should re-evaluate\r\n        let context = self.context();\r\n\r\n        tracing::trace!(\"updating widget\");\r\n        self.update.insert(\r\n            self.widget\r\n                .as_mut()\r\n                .unwrap()\r\n                .update(&layout_node, context, &self.info),\r\n        );\r\n\r\n        // check if app should re-evaluate layout\r\n        if self.update.is_set(Update::LAYOUT | Update::FORCE) {\r\n            tracing::trace_span!(\"layout\").in_scope(|| {\r\n                // clear all nodes (except root window node)\r\n                self.taffy\r\n                    .set_children(self.window_node, &[])\r\n                    .expect(\"Failed to set children\");\r\n\r\n                let style = self.widget.as_ref().unwrap().layout_style();\r\n\r\n                self.layout_widget(self.window_node, &style)\r\n                    .expect(\"Failed to layout window\");\r\n\r\n                self.compute_layout().expect(\"Failed to compute layout\");\r\n\r\n                layout_node = self\r\n                    .collect_layout(\r\n                        self.taffy.child_at_index(self.window_node, 0).unwrap(),\r\n                        &style,\r\n                    )\r\n                    .expect(\"Failed to collect layout\");\r\n            });\r\n        }\r\n\r\n        // check if app should redraw\r\n        if self\r\n            .update\r\n            .is_set(Update::DRAW | Update::LAYOUT | Update::FORCE)\r\n        {\r\n            tracing::trace_span!(\"draw\").in_scope(|| {\r\n                // clear scene\r\n                tracing::trace!(\"resetting vector graphics interface scene\");\r\n                self.scene.reset();\r\n\r\n                let context = self.context();\r\n\r\n                tracing::trace!(\"drawing root widget\");\r\n                self.widget.as_mut().unwrap().render(\r\n                    &mut self.scene,\r\n                    &mut self.config.theme,\r\n                    &layout_node,\r\n                    &self.info,\r\n                    context,\r\n                );\r\n\r\n                let window = self.window.clone().expect(\"Window not initialized\");\r\n\r\n                // check surface validity\r\n                if window.inner_size().width != 0 && window.inner_size().height != 0 {\r\n                    self.render(window, event_loop)\r\n                        .expect(\"Failed rendering process\");\r\n                } else {\r\n                    tracing::debug!(\"skipping render due to invalid surface\");\r\n                }\r\n            });\r\n        }\r\n\r\n        // check if app should re-evaluate\r\n        if self.update.is_set(Update::EVAL) {\r\n            tracing::trace!(\"re-evaluating application state\");\r\n        }\r\n\r\n        // update the app if requested\r\n        if self.update.is_set(Update::EXIT) {\r\n            tracing::trace!(\"exiting event loop\");\r\n            event_loop.exit();\r\n            return;\r\n        }\r\n\r\n        // reset AppInfo and update states\r\n        tracing::trace!(\"resetting app info and update states\");\r\n        self.info.reset();\r\n        self.update.clear();\r\n\r\n        // update diagnostics\r\n        self.info.diagnostics.first_run = false;\r\n        self.info.diagnostics.do_update();\r\n    }\r\n\r\n    #[cold]\r\n    fn close(&mut self, window: Arc<Window>, event_loop: &ActiveEventLoop) {\r\n        tracing::trace!(\"close requested\");\r\n\r\n        self.graphics\r\n            .destroy(window, event_loop)\r\n            .expect(\"Failed to destroy vector graphics interface\");\r\n\r\n        if self.config.window.close_on_request {\r\n            tracing::info!(\"exiting event loop\");\r\n            event_loop.exit();\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T, W, S, F, V> ApplicationHandler for AppHandler<T, W, S, F, V>\r\nwhere\r\n    T: Theme,\r\n    W: Widget,\r\n    F: Fn(AppContext, S) -> W,\r\n    V: VectorGraphicsInterface,\r\n{\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip_all)]\r\n    fn resumed(&mut self, event_loop: &ActiveEventLoop) {\r\n        tracing::debug!(\"resuming plugins\");\r\n        self.plugins.run(|pl| {\r\n            pl.on_resume(\r\n                &mut self.config,\r\n                &mut self.scene,\r\n                &mut self.taffy,\r\n                self.window_node,\r\n                &mut self.info,\r\n                &self.update,\r\n                event_loop,\r\n            )\r\n        });\r\n\r\n        tracing::info!(\"creating window\");\r\n        let window = Arc::new(\r\n            event_loop\r\n                .create_window(self.attrs.clone())\r\n                .expect(\"Failed to create window\"),\r\n        );\r\n\r\n        tracing::info!(\"initializing layout\");\r\n        let size = window.inner_size();\r\n\r\n        self.taffy\r\n            .set_style(\r\n                self.window_node,\r\n                Style {\r\n                    size: Size::<Dimension> {\r\n                        width: Dimension::length(size.width as f32),\r\n                        height: Dimension::length(size.height as f32),\r\n                    },\r\n                    ..Default::default()\r\n                },\r\n            )\r\n            .expect(\"Failed to set window node style\");\r\n\r\n        tracing::info!(\"initializing vector graphics interface\");\r\n        self.graphics\r\n            .init(window.clone(), event_loop)\r\n            .expect(\"Failed to initialize vector graphics interface\");\r\n\r\n        tracing::info!(\"building root widget\");\r\n        self.widget = Some((self.builder)(\r\n            AppContext::new(self.update.clone(), self.info.diagnostics),\r\n            self.state.take().unwrap(),\r\n        ));\r\n\r\n        self.window = Some(window);\r\n    }\r\n\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip_all, fields(event =\r\n        ?event))]\r\n    fn window_event(\r\n        &mut self,\r\n        event_loop: &ActiveEventLoop,\r\n        window_id: WindowId,\r\n        mut event: WindowEvent,\r\n    ) {\r\n        tracing::trace!(\"running plugin window event\");\r\n        self.plugins.run(|pl| {\r\n            pl.on_window_event(\r\n                &mut event,\r\n                &mut self.config,\r\n                self.window.as_ref().unwrap(),\r\n                &mut self.scene,\r\n                &mut self.taffy,\r\n                self.window_node,\r\n                &mut self.info,\r\n                &self.update,\r\n                event_loop,\r\n            )\r\n        });\r\n\r\n        if let Some(window) = &self.window\r\n            && window.id() == window_id\r\n        {\r\n            match event {\r\n                WindowEvent::Resized(new_size) => {\r\n                    tracing::debug!(\"resizing window to {new_size:?}\");\r\n\r\n                    if new_size.width != 0 && new_size.height != 0 {\r\n                        tracing::trace!(\"resizing vector graphics interface\");\r\n                        self.graphics\r\n                            .resize(\r\n                                window.clone(),\r\n                                event_loop,\r\n                                Vector2::new(new_size.width, new_size.height),\r\n                            )\r\n                            .expect(\"Failed to resize vector graphics interface\");\r\n\r\n                        tracing::trace!(\"resizing root layout node\");\r\n                        self.taffy\r\n                            .set_style(\r\n                                self.window_node,\r\n                                Style {\r\n                                    size: Size::<Dimension> {\r\n                                        width: Dimension::length(new_size.width as f32),\r\n                                        height: Dimension::length(new_size.height as f32),\r\n                                    },\r\n                                    ..Default::default()\r\n                                },\r\n                            )\r\n                            .expect(\"Failed to set window node style\");\r\n\r\n                        self.info.size =\r\n                            Vector2::new(new_size.width as f64, new_size.height as f64);\r\n\r\n                        self.update\r\n                            .insert(Update::EVAL | Update::DRAW | Update::LAYOUT);\r\n                    } else {\r\n                        tracing::trace!(\"window size is 0x0, ignoring resize event\");\r\n                    }\r\n                },\r\n\r\n                WindowEvent::CloseRequested => {\r\n                    self.close(window.clone(), event_loop);\r\n                },\r\n\r\n                WindowEvent::RedrawRequested => {\r\n                    window.request_redraw();\r\n\r\n                    // update diagnostics frames\r\n                    self.info.diagnostics.do_frame();\r\n\r\n                    if self.update.is_set(Update::EVAL) {\r\n                        self.update.remove(Update::EVAL);\r\n                        self.update(event_loop);\r\n                    }\r\n\r\n                    // update diagnostics computations\r\n                    tracing::trace!(\"updating diagnostics\");\r\n                    self.info.diagnostics.tick();\r\n\r\n                    tracing::debug!(\"updates per sec {}\", self.info.diagnostics.updates_per_sec);\r\n                    tracing::debug!(\"frames per sec {}\", self.info.diagnostics.frames_per_sec);\r\n                },\r\n\r\n                WindowEvent::CursorLeft { .. } => {\r\n                    self.info.cursor_pos = None;\r\n                    self.update.insert(Update::EVAL);\r\n                },\r\n\r\n                WindowEvent::CursorMoved { position, .. } => {\r\n                    self.info.cursor_pos = Some(Vector2::new(position.x as f32, position.y as f32));\r\n                    self.update.insert(Update::EVAL);\r\n                },\r\n\r\n                WindowEvent::KeyboardInput {\r\n                    event,\r\n                    device_id,\r\n                    is_synthetic,\r\n                } => {\r\n                    if !is_synthetic {\r\n                        tracing::trace!(\"keyboard input {event:?}\");\r\n\r\n                        self.info.keys.push((device_id, event));\r\n                        self.update.insert(Update::EVAL);\r\n                    }\r\n                },\r\n\r\n                WindowEvent::MouseInput {\r\n                    device_id,\r\n                    button,\r\n                    state,\r\n                } => {\r\n                    tracing::trace!(\"mouse input {button:?} {state:?}\");\r\n\r\n                    self.info.buttons.push((device_id, button, state));\r\n                    self.update.insert(Update::EVAL);\r\n                },\r\n\r\n                WindowEvent::MouseWheel { delta, .. } => {\r\n                    tracing::trace!(\"mouse wheel {delta:?}\");\r\n                    self.info.mouse_scroll_delta = Some(delta);\r\n                    self.update.insert(Update::EVAL);\r\n                },\r\n\r\n                WindowEvent::Destroyed => tracing::info!(\"window destroyed\"),\r\n\r\n                _ => (),\r\n            }\r\n        }\r\n    }\r\n\r\n    #[cold]\r\n    #[tracing::instrument(level = \"trace\", skip_all)]\r\n    fn suspended(&mut self, event_loop: &ActiveEventLoop) {\r\n        tracing::trace!(\"destroying vector graphics interface\");\r\n        let window = self.window.clone().unwrap();\r\n        self.graphics\r\n            .uninit(window, event_loop)\r\n            .expect(\"Failed to destroy vector graphics interface\");\r\n\r\n        tracing::trace!(\"destroying window\");\r\n        self.window = None;\r\n\r\n        tracing::trace!(\"running plugin suspensions\");\r\n        self.plugins.run(|pl| {\r\n            pl.on_suspended(\r\n                &mut self.config,\r\n                &mut self.scene,\r\n                &mut self.taffy,\r\n                self.window_node,\r\n                &mut self.info,\r\n                &self.update,\r\n                event_loop,\r\n            )\r\n        });\r\n\r\n        self.info.reset();\r\n    }\r\n}\r\n","traces":[{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":259},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","app","info.rs"],"content":"use nalgebra::Vector2;\r\nuse winit::event::{DeviceId, ElementState, KeyEvent, MouseButton, MouseScrollDelta};\r\n\r\nuse crate::app::diagnostics::Diagnostics;\r\nuse crate::app::font_ctx::FontContext;\r\n\r\n/// The application information container.\r\npub struct AppInfo {\r\n    /// The position of the cursor. If [None], the cursor left the window.\r\n    pub cursor_pos: Option<Vector2<f32>>,\r\n    /// The fired key events.\r\n    pub keys: Vec<(DeviceId, KeyEvent)>,\r\n    /// The fired mouse button events.\r\n    pub buttons: Vec<(DeviceId, MouseButton, ElementState)>,\r\n    /// The mouse scroll delta, if a [winit::event::WindowEvent::MouseWheel] event was fired.\r\n    pub mouse_scroll_delta: Option<MouseScrollDelta>,\r\n    /// App Diagnostics.\r\n    pub diagnostics: Diagnostics,\r\n    /// The current font context.\r\n    pub font_context: FontContext,\r\n    /// The size of the window.\r\n    pub size: Vector2<f64>,\r\n}\r\n\r\nimpl AppInfo {\r\n    /// Reset the application information for a new frame.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip_all)]\r\n    pub fn reset(&mut self) {\r\n        self.buttons.clear();\r\n        self.keys.clear();\r\n        self.mouse_scroll_delta = None;\r\n    }\r\n}\r\n\r\nimpl Default for AppInfo {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self {\r\n            cursor_pos: None,\r\n            keys: Vec::with_capacity(4),\r\n            buttons: Vec::with_capacity(2),\r\n            mouse_scroll_delta: None,\r\n            diagnostics: Diagnostics::default(),\r\n            font_context: FontContext::default(),\r\n            size: Vector2::new(0.0, 0.0),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","app","mod.rs"],"content":"use crate::app::context::AppContext;\r\nuse crate::app::runner::MayRunner;\r\nuse crate::config::MayConfig;\r\nuse crate::plugin::PluginManager;\r\nuse crate::vgi::VectorGraphicsInterface;\r\nuse crate::widget::Widget;\r\nuse maycoon_theme::theme::Theme;\r\n\r\n/// Contains diagnostics data for the application.\r\npub mod diagnostics;\r\n\r\n/// Contains the font context structure.\r\npub mod font_ctx;\r\n\r\n/// Contains the application handler.\r\npub mod handler;\r\n\r\n/// Contains the application information structure.\r\npub mod info;\r\n\r\n/// Contains the update mode bitflag.\r\npub mod update;\r\n\r\n/// Contains the [AppContext] structure for access to the application lifecycle.\r\npub mod context;\r\n\r\n/// Contains the [MayRunner] structure to create and run an application using `winit`.\r\npub mod runner;\r\n\r\n/// The main application interface.\r\n///\r\n/// Contains basic functions for the [MayRunner] to create and run an application.\r\npub trait Application: Sized {\r\n    /// The theme of the application and its widgets.\r\n    ///\r\n    /// See [maycoon_theme::theme] for built-in themes.\r\n    type Theme: Theme;\r\n\r\n    // TODO: Change to default type, once (associated type defaults)[https://github.com/rust-lang/rust/issues/29661] is stabilized.\r\n    /// The vector graphics interface to use for rendering.\r\n    ///\r\n    /// See [VectorGraphicsInterface] for more.\r\n    type Graphics: VectorGraphicsInterface;\r\n\r\n    /// The global state of the application.\r\n    type State;\r\n\r\n    /// Renders/builds the application's widgets.\r\n    ///\r\n    /// This function will be passed to the [MayRunner] to create and run the application.\r\n    fn build(context: AppContext, state: Self::State) -> impl Widget;\r\n\r\n    /// Returns the [MayConfig] for the application.\r\n    fn config(&self) -> MayConfig<Self::Theme, Self::Graphics>;\r\n\r\n    /// Builds and returns the [PluginManager] for the application.\r\n    #[inline(always)]\r\n    fn plugins(&self) -> PluginManager<Self::Theme, Self::Graphics> {\r\n        PluginManager::new()\r\n    }\r\n\r\n    /// Initializes the backend application data.\r\n    ///\r\n    /// This function is called before the actual launch of the app.\r\n    ///\r\n    /// The default implementation just initializes the task runner.\r\n    #[inline(always)]\r\n    fn init(&self) {\r\n        #[cfg(feature = \"tokio-runner\")]\r\n        {\r\n            tracing::info!(\"initializing tokio task runner\");\r\n            crate::tasks::init(crate::tasks::runner::TaskRunner::Tokio(\r\n                crate::tasks::runner::tokio::TaskRunner::new(\r\n                    true, None, None, None, None, None, None, None,\r\n                ),\r\n            ));\r\n        }\r\n    }\r\n\r\n    /// Runs the application using the [MayRunner].\r\n    ///\r\n    /// Override this method if you want to use a custom event loop.\r\n    #[inline(always)]\r\n    fn run(self, state: Self::State) {\r\n        let config = self.config();\r\n\r\n        tracing::info_span!(\"init\").in_scope(|| self.init());\r\n\r\n        tracing::info!(\"launching application runner with config {config:?}\");\r\n        MayRunner::<Self::Theme, Self::Graphics>::new(config).run(\r\n            state,\r\n            Self::build,\r\n            self.plugins(),\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","app","runner.rs"],"content":"use crate::app::context::AppContext;\r\nuse crate::app::font_ctx::FontContext;\r\nuse crate::app::handler::AppHandler;\r\nuse crate::app::update::UpdateManager;\r\nuse crate::config::MayConfig;\r\nuse crate::plugin::PluginManager;\r\nuse crate::vgi::VectorGraphicsInterface;\r\nuse crate::widget::Widget;\r\nuse maycoon_theme::theme::Theme;\r\nuse peniko::FontData;\r\nuse winit::dpi::{LogicalPosition, LogicalSize, Position, Size};\r\nuse winit::event_loop::EventLoopBuilder;\r\nuse winit::window::WindowAttributes;\r\n\r\n/// The core Application structure.\r\npub struct MayRunner<T: Theme, V: VectorGraphicsInterface> {\r\n    config: MayConfig<T, V>,\r\n    font_ctx: FontContext,\r\n}\r\n\r\nimpl<T: Theme, V: VectorGraphicsInterface> MayRunner<T, V> {\r\n    /// Create a new App with the given [MayConfig].\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"trace\", skip_all)]\r\n    pub fn new(config: MayConfig<T, V>) -> Self {\r\n        Self {\r\n            config,\r\n            font_ctx: FontContext::default(),\r\n        }\r\n    }\r\n\r\n    /// Loads a new font into the font context.\r\n    ///\r\n    /// See [FontContext::load] for more.\r\n    #[inline(always)]\r\n    pub fn with_font(self, name: impl ToString, font: FontData) -> Self {\r\n        Self {\r\n            config: self.config,\r\n            font_ctx: self.font_ctx.load(name, font).expect(\"Font already loaded\"),\r\n        }\r\n    }\r\n\r\n    /// Set the font context. Can be used to configure fonts.\r\n    #[inline(always)]\r\n    pub fn with_font_context(mut self, font_ctx: FontContext) -> Self {\r\n        self.font_ctx = font_ctx;\r\n        self\r\n    }\r\n\r\n    /// Run the application with given widget and state.\r\n    #[inline(always)]\r\n    #[tracing::instrument(level = \"info\", skip_all)]\r\n    pub fn run<S, W, F>(mut self, state: S, builder: F, mut plugins: PluginManager<T, V>)\r\n    where\r\n        W: Widget,\r\n        F: Fn(AppContext, S) -> W,\r\n    {\r\n        tracing::trace!(\"building event loop\");\r\n        let mut event_loop = EventLoopBuilder::default()\r\n            .build()\r\n            .expect(\"Failed to create event loop\");\r\n\r\n        let mut attrs = WindowAttributes::default()\r\n            .with_inner_size(LogicalSize::new(\r\n                self.config.window.size.x,\r\n                self.config.window.size.y,\r\n            ))\r\n            .with_resizable(self.config.window.resizable)\r\n            .with_enabled_buttons(self.config.window.buttons)\r\n            .with_title(self.config.window.title.clone())\r\n            .with_maximized(self.config.window.maximized)\r\n            .with_visible(self.config.window.visible)\r\n            .with_transparent(self.config.window.transparent)\r\n            .with_blur(self.config.window.blur)\r\n            .with_decorations(self.config.window.decorations)\r\n            .with_window_icon(self.config.window.icon.clone())\r\n            .with_content_protected(self.config.window.content_protected)\r\n            .with_window_level(self.config.window.level)\r\n            .with_active(self.config.window.active)\r\n            .with_cursor(self.config.window.cursor.clone());\r\n\r\n        // since `with_max_inner_size()` doesn't support `Option` values, we need to manually set it\r\n        attrs.max_inner_size = self\r\n            .config\r\n            .window\r\n            .max_size\r\n            .map(|v| Size::Logical(LogicalSize::new(v.x, v.y)));\r\n\r\n        // since `with_min_inner_size()` doesn't support `Option` values, we need to manually set it\r\n        attrs.min_inner_size = self\r\n            .config\r\n            .window\r\n            .min_size\r\n            .map(|v| Size::Logical(LogicalSize::new(v.x, v.y)));\r\n\r\n        // since `with_position()` doesn't support `Option` values, we need to manually set it\r\n        attrs.position = self\r\n            .config\r\n            .window\r\n            .position\r\n            .map(|v| Position::Logical(LogicalPosition::new(v.x, v.y)));\r\n\r\n        // since `with_resize_increments()` doesn't support `Option` values, we need to manually set it\r\n        attrs.resize_increments = self\r\n            .config\r\n            .window\r\n            .resize_increments\r\n            .map(|v| Size::Logical(LogicalSize::new(v.x, v.y)));\r\n\r\n        tracing::trace!(\"creating update manager\");\r\n        let update = UpdateManager::new();\r\n\r\n        tracing::trace!(\"initializing plugins\");\r\n        plugins.run(|pl| pl.init(&mut event_loop, &update, &mut attrs, &mut self.config));\r\n\r\n        tracing::info!(\"running application handler\");\r\n        event_loop\r\n            .run_app(&mut AppHandler::new(\r\n                attrs,\r\n                self.config,\r\n                builder,\r\n                state,\r\n                self.font_ctx,\r\n                update,\r\n                plugins,\r\n            ))\r\n            .expect(\"Failed to run event loop\");\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":62},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","app","update.rs"],"content":"use bitflags::bitflags;\r\nuse std::sync::Arc;\r\nuse std::sync::atomic::{AtomicU8, Ordering};\r\n\r\nbitflags! {\r\n    /// Update bitflags to define which part of the App should Update.\r\n    ///\r\n    /// Possible values:\r\n    /// - **EVAL** - Re-evaluate the widget tree.\r\n    /// - **DRAW** - Re-draw the widget tree.\r\n    /// - **LAYOUT** - Re-layout the widget tree.\r\n    /// - **FORCE** - Force the App to re-evaluate, re-draw and re-layout the widget tree.\r\n    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\r\n    pub struct Update: u8 {\r\n        /// Re-evaluate the widget tree.\r\n        const EVAL   = 0b00000001;\r\n        /// Re-draw the widget tree.\r\n        const DRAW   = 0b00000010;\r\n        /// Re-layout the widget tree.\r\n        const LAYOUT = 0b00000100;\r\n        /// Force the App to re-evaluate, re-draw and re-layout the widget tree.\r\n        const FORCE  = 0b00001000;\r\n        /// Makes the App exit.\r\n        const EXIT   = 0b00010000;\r\n    }\r\n}\r\n\r\n/// Manages updates for the application lifecycle.\r\n///\r\n/// It's using atomic operations to ensure lockless thread-safety.\r\n#[derive(Clone, Debug)]\r\npub struct UpdateManager {\r\n    update: Arc<AtomicU8>,\r\n}\r\n\r\nimpl UpdateManager {\r\n    /// Creates a new `UpdateManager`.\r\n    #[inline(always)]\r\n    pub fn new() -> Self {\r\n        Self {\r\n            update: Arc::new(AtomicU8::new(Update::FORCE.bits())),\r\n        }\r\n    }\r\n\r\n    /// Inserts the given `Update` into the `UpdateManager` using bitwise OR.\r\n    #[inline(always)]\r\n    pub fn insert(&self, update: Update) {\r\n        self.update.fetch_or(update.bits(), Ordering::AcqRel);\r\n    }\r\n\r\n    /// Removes the given `Update` from the `UpdateManager` using bitwise AND.\r\n    #[inline(always)]\r\n    pub fn remove(&self, update: Update) {\r\n        self.update.fetch_and(!update.bits(), Ordering::AcqRel);\r\n    }\r\n\r\n    /// Returns the current `Update` of the `UpdateManager`.\r\n    #[inline(always)]\r\n    pub fn get(&self) -> Update {\r\n        Update::from_bits(self.update.load(Ordering::Acquire))\r\n            .expect(\"failed to decode update bits\")\r\n    }\r\n\r\n    /// Sets the current `Update` of the `UpdateManager`.\r\n    #[inline(always)]\r\n    pub fn set(&self, update: Update) {\r\n        self.update.store(update.bits(), Ordering::Release);\r\n    }\r\n\r\n    /// Clears the current `Update` flags of the `UpdateManager`.\r\n    #[inline(always)]\r\n    pub fn clear(&self) {\r\n        self.update.store(0, Ordering::Release);\r\n    }\r\n\r\n    /// Checks if the given [Update] flag is set.\r\n    ///\r\n    /// Equivalent to `UpdateManager.get().intersects(flag)`.\r\n    #[inline(always)]\r\n    pub fn is_set(&self, flag: Update) -> bool {\r\n        self.get().intersects(flag)\r\n    }\r\n}\r\n\r\nimpl Default for UpdateManager {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self::new()\r\n    }\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","component.rs"],"content":"use crate::app::context::AppContext;\r\nuse crate::app::info::AppInfo;\r\nuse crate::app::update::Update;\r\nuse crate::layout::{LayoutNode, LayoutStyle, StyleNode};\r\nuse crate::signal::MaybeSignal;\r\nuse crate::vgi::Scene;\r\nuse crate::widget::{BoxedWidget, Widget, WidgetChildExt, WidgetChildrenExt, WidgetLayoutExt};\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\nuse std::fmt::Debug;\r\nuse std::ops::{Deref, DerefMut};\r\n\r\n/// A trait for creating a [Widget] from simple functions.\r\n///\r\n/// Simplifies the creation of your own widgets.\r\npub trait Component {\r\n    /// Builds the inner widget.\r\n    fn build(&self, context: AppContext) -> impl Widget + 'static;\r\n\r\n    /// The id of this widget/component.\r\n    fn widget_id(&self) -> WidgetId;\r\n\r\n    /// Composes this component into a [Widget] using [ComposedWidget].\r\n    #[inline(always)]\r\n    fn compose(self) -> Composed<Self>\r\n    where\r\n        Self: Sized,\r\n    {\r\n        Composed {\r\n            component: self,\r\n            widget: None,\r\n        }\r\n    }\r\n}\r\n\r\n/// A [Widget] created from a [Component].\r\npub struct Composed<C: Component> {\r\n    component: C,\r\n    widget: Option<BoxedWidget>,\r\n}\r\n\r\nimpl<C: Component> Composed<C> {\r\n    /// Creates a new [Composed] widget from a [Component].\r\n    #[inline(always)]\r\n    pub fn new(component: C) -> Self {\r\n        Self {\r\n            component,\r\n            widget: None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl<C: Component> Widget for Composed<C> {\r\n    #[inline(always)]\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        info: &AppInfo,\r\n        context: AppContext,\r\n    ) {\r\n        if let Some(widget) = &mut self.widget {\r\n            widget.render(scene, theme, layout_node, info, context)\r\n        } else {\r\n            self.widget = Some(Box::new(self.component.build(context.clone())));\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        if let Some(widget) = &self.widget {\r\n            widget.layout_style()\r\n        } else {\r\n            StyleNode {\r\n                style: LayoutStyle::default(),\r\n                children: Vec::new(),\r\n            }\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn update(&mut self, layout: &LayoutNode, context: AppContext, info: &AppInfo) -> Update {\r\n        if let Some(widget) = &mut self.widget {\r\n            widget.update(layout, context, info)\r\n        } else {\r\n            self.widget = Some(Box::new(self.component.build(context.clone())));\r\n            Update::FORCE\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        self.component.widget_id()\r\n    }\r\n}\r\n\r\nimpl<C: Component + WidgetChildrenExt> WidgetChildrenExt for Composed<C> {\r\n    #[inline(always)]\r\n    fn set_children(&mut self, children: Vec<BoxedWidget>) {\r\n        self.component.set_children(children)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn with_children(self, children: Vec<BoxedWidget>) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self.component.with_children(children).compose()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn add_child(&mut self, child: impl Widget + 'static) {\r\n        self.component.add_child(child)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn with_child(self, child: impl Widget + 'static) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self.component.with_child(child).compose()\r\n    }\r\n}\r\n\r\nimpl<C: Component + WidgetChildExt> WidgetChildExt for Composed<C> {\r\n    #[inline(always)]\r\n    fn set_child(&mut self, child: impl Widget + 'static) {\r\n        self.component.set_child(child)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn with_child(self, child: impl Widget + 'static) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self.component.with_child(child).compose()\r\n    }\r\n}\r\n\r\nimpl<C: Component + WidgetLayoutExt> WidgetLayoutExt for Composed<C> {\r\n    #[inline(always)]\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.component.set_layout_style(layout_style)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn with_layout_style(self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self.component.with_layout_style(layout_style).compose()\r\n    }\r\n}\r\n\r\nimpl<C: Component + Clone> Clone for Composed<C> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            component: self.component.clone(),\r\n            widget: None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl<C: Component + Debug> Debug for Composed<C> {\r\n    #[inline(always)]\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        f.debug_struct(\"ComposedWidget\")\r\n            .field(\"component\", &self.component)\r\n            .field(\"widget\", &self.widget.as_ref().map(|_| \"?\".to_string()))\r\n            .finish()\r\n    }\r\n}\r\n\r\nimpl<C: Component> Deref for Composed<C> {\r\n    type Target = C;\r\n\r\n    #[inline(always)]\r\n    fn deref(&self) -> &Self::Target {\r\n        &self.component\r\n    }\r\n}\r\n\r\nimpl<C: Component> DerefMut for Composed<C> {\r\n    #[inline(always)]\r\n    fn deref_mut(&mut self) -> &mut Self::Target {\r\n        &mut self.component\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":44},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","config.rs"],"content":"use nalgebra::{Point2, Vector2};\r\npub use winit::window::{\r\n    BadIcon, Cursor, CursorIcon, CustomCursor, Icon as WindowIcon, WindowButtons, WindowLevel,\r\n};\r\n\r\nuse crate::vgi::VectorGraphicsInterface;\r\nuse maycoon_theme::theme::Theme;\r\n\r\n/// Maycoon Application Configuration Structure.\r\n#[derive(Clone, Debug)]\r\npub struct MayConfig<T: Theme, V: VectorGraphicsInterface> {\r\n    /// Window Configuration\r\n    pub window: WindowConfig,\r\n    /// Theme of the Application.\r\n    pub theme: T,\r\n    /// The configuration of the vector graphics interface.\r\n    pub graphics: V::Config,\r\n}\r\n\r\nimpl<T: Default + Theme, V: VectorGraphicsInterface> Default for MayConfig<T, V> {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self {\r\n            window: WindowConfig::default(),\r\n            theme: T::default(),\r\n            graphics: V::Config::default(),\r\n        }\r\n    }\r\n}\r\n\r\n/// Window configuration.\r\n#[derive(Clone, Debug)]\r\npub struct WindowConfig {\r\n    /// The title of the window.\r\n    pub title: String,\r\n    /// The inner size of the window.\r\n    pub size: Vector2<f64>,\r\n    /// The minimum size of the window.\r\n    pub min_size: Option<Vector2<f64>>,\r\n    /// The maximum size of the window.\r\n    pub max_size: Option<Vector2<f64>>,\r\n    /// If the window should be resizeable.\r\n    pub resizable: bool,\r\n    /// If the window should be maximized on startup.\r\n    pub maximized: bool,\r\n    /// The window mode.\r\n    pub mode: WindowMode,\r\n    /// The window level.\r\n    pub level: WindowLevel,\r\n    /// If the window should be visible on startup.\r\n    pub visible: bool,\r\n    /// If the window background should be blurred.\r\n    pub blur: bool,\r\n    /// If the window background should be transparent. May not be compatible on all system.\r\n    pub transparent: bool,\r\n    /// The desired initial position for the window.\r\n    pub position: Option<Point2<f64>>,\r\n    /// If the window should be active/focused on startup.\r\n    pub active: bool,\r\n    /// The enabled window buttons.\r\n    pub buttons: WindowButtons,\r\n    /// If the window should be decorated (have borders).\r\n    pub decorations: bool,\r\n    /// The resize increments of the window. Not supported everywhere.\r\n    pub resize_increments: Option<Vector2<f64>>,\r\n    /// Prevents window capturing by some apps (not all though).\r\n    pub content_protected: bool,\r\n    /// The window icon.\r\n    pub icon: Option<WindowIcon>,\r\n    /// The window cursor.\r\n    pub cursor: Cursor,\r\n    /// If the window should exit/close on close request (pressing the close window button).\r\n    pub close_on_request: bool,\r\n}\r\n\r\nimpl Default for WindowConfig {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self {\r\n            title: \"New App\".to_string(),\r\n            size: Vector2::new(800.0, 600.0),\r\n            min_size: None,\r\n            max_size: None,\r\n            resizable: true,\r\n            maximized: false,\r\n            mode: WindowMode::default(),\r\n            level: Default::default(),\r\n            visible: true,\r\n            blur: false,\r\n            transparent: false,\r\n            position: None,\r\n            active: true,\r\n            buttons: WindowButtons::all(),\r\n            decorations: true,\r\n            resize_increments: None,\r\n            content_protected: false,\r\n            icon: None,\r\n            cursor: Cursor::default(),\r\n            close_on_request: true,\r\n        }\r\n    }\r\n}\r\n\r\n/// The window mode.\r\n#[derive(Clone, Debug, Default)]\r\npub enum WindowMode {\r\n    /// The default windowed mode.\r\n    #[default]\r\n    Windowed,\r\n    /// Size the window to fill the screen and remove borders. This is more modern, than default Fullscreen.\r\n    Borderless,\r\n    /// Legacy Fullscreen mode.\r\n    Fullscreen,\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","layout.rs"],"content":"use nalgebra::Vector2;\r\npub use taffy::{\r\n    AlignContent, AlignItems, AlignSelf, Dimension, Display, FlexDirection, FlexWrap, GridAutoFlow,\r\n    GridPlacement, JustifyContent, JustifyItems, JustifySelf, Layout, LengthPercentage,\r\n    LengthPercentageAuto, Line, NodeId, Overflow, Position, Rect, TaffyError, TaffyResult,\r\n    TaffyTree,\r\n};\r\n\r\n/// The tiniest difference two floats should have, in a layout context, to be considered \"unequal\".\r\n///\r\n/// This value is equal to half a pixel.\r\n///\r\n/// When comparing two floats in a layout context,\r\n/// we can check if the difference is higher than this threshold,\r\n/// in order to determine if redrawing is necessary.\r\n///\r\n/// See [equal] for more.\r\npub const LAYOUT_EPSILON: f32 = 0.5;\r\n\r\n/// Checks if two floats are equal, within the [LAYOUT_EPSILON] threshold.\r\n///\r\n/// This is useful for comparing float values in a layout context,\r\n/// as floating point precision can cause small differences that are not significant\r\n/// and therefore need no redraw.\r\n///\r\n/// Example:\r\n/// ```\r\n/// # use maycoon_core::layout;\r\n///\r\n/// // Significant change. Should redraw.\r\n/// assert!(!layout::equal(10.0, 20.0));\r\n///\r\n/// // Insignificant change. Should not redraw.\r\n/// assert!(layout::equal(10.0, 10.005));\r\n/// ```\r\n#[inline(always)]\r\npub const fn equal(x: f32, y: f32) -> bool {\r\n    (x - y).abs() < LAYOUT_EPSILON\r\n}\r\n\r\n/// Checks if the given point intersects the given layout.\r\n///\r\n/// This can be used to check if the cursor is hovering on a widget.\r\n///\r\n/// Example:\r\n/// ```\r\n/// # use taffy::Layout;\r\n/// # use maycoon_core::app::info::AppInfo;\r\n/// # use maycoon_core::layout;\r\n/// # let info = AppInfo::default();\r\n/// # let layout = Layout::default();\r\n///\r\n/// if let Some(cursor) = info.cursor_pos && layout::intersects(cursor, &layout) {\r\n///     println!(\"Hovering on widget!\");\r\n/// }\r\n/// ```\r\n#[inline(always)]\r\npub fn intersects(point: Vector2<f32>, layout: &Layout) -> bool {\r\n    point.x >= layout.location.x\r\n        && point.x <= layout.location.x + layout.size.width\r\n        && point.y >= layout.location.y\r\n        && point.y <= layout.location.y + layout.size.height\r\n}\r\n\r\n/// Defines different aspects and properties of a widget layout.\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct LayoutStyle {\r\n    /// What layout strategy should be used?\r\n    pub display: Display,\r\n\r\n    /// How children overflowing their container should affect layout.\r\n    pub overflow: (Overflow, Overflow),\r\n\r\n    /// How much space (in points) should be reserved for scrollbars.\r\n    pub scrollbar_width: f32,\r\n\r\n    /// What should the position value of this struct use as a base offset?\r\n    pub position: Position,\r\n\r\n    /// How should the position of this element be tweaked relative to the layout defined?\r\n    pub inset: Rect<LengthPercentageAuto>,\r\n\r\n    /// Sets the initial size of the item.\r\n    pub size: Vector2<Dimension>,\r\n\r\n    /// Controls the minimum size of the item.\r\n    pub min_size: Vector2<Dimension>,\r\n\r\n    /// Controls the maximum size of the item.\r\n    pub max_size: Vector2<Dimension>,\r\n\r\n    /// Sets the preferred aspect ratio for the item\r\n    ///\r\n    /// The ratio is calculated as width divided by height.\r\n    pub aspect_ratio: Option<f32>,\r\n\r\n    /// How large should the margin be on each side?\r\n    pub margin: Rect<LengthPercentageAuto>,\r\n\r\n    /// How large should the padding be on each side?\r\n    pub padding: Rect<LengthPercentage>,\r\n\r\n    /// How large should the border be on each side?\r\n    pub border: Rect<LengthPercentage>,\r\n\r\n    /// How this node's children aligned in the cross/block axis?\r\n    pub align_items: Option<AlignItems>,\r\n\r\n    /// How this node should be aligned in the cross/block axis\r\n    /// Falls back to the parents [AlignItems] if not set.\r\n    pub align_self: Option<AlignSelf>,\r\n\r\n    /// How this node's children should be aligned in the inline axis.\r\n    pub justify_items: Option<AlignItems>,\r\n\r\n    /// How this node should be aligned in the inline axis\r\n    /// Falls back to the parents [JustifyItems] if not set.\r\n    pub justify_self: Option<AlignSelf>,\r\n\r\n    /// How should content contained within this item be aligned in the cross/block axis?\r\n    pub align_content: Option<AlignContent>,\r\n\r\n    /// How should content contained within this item be aligned in the main/inline axis?\r\n    pub justify_content: Option<JustifyContent>,\r\n\r\n    /// How large should the gaps between items in a grid or flex container be?\r\n    pub gap: Vector2<LengthPercentage>,\r\n\r\n    /// Which direction does the main axis flow in?\r\n    pub flex_direction: FlexDirection,\r\n\r\n    /// Should elements wrap, or stay in a single line?\r\n    pub flex_wrap: FlexWrap,\r\n\r\n    /// Sets the initial main axis size of the item.\r\n    pub flex_basis: Dimension,\r\n\r\n    /// The relative rate at which this item grows when it is expanding to fill space.\r\n    ///\r\n    /// 0.0 is the default value, and this value must be positive.\r\n    pub flex_grow: f32,\r\n\r\n    /// The relative rate at which this item shrinks when it is contracting to fit into space.\r\n    ///\r\n    /// 1.0 is the default value, and this value must be positive.\r\n    pub flex_shrink: f32,\r\n\r\n    /// Controls how items get placed into the grid for auto-placed items.\r\n    pub grid_auto_flow: GridAutoFlow,\r\n\r\n    /// Defines which row in the grid the item should start and end at.\r\n    pub grid_row: Line<GridPlacement>,\r\n\r\n    /// Defines which column in the grid the item should start and end at.\r\n    pub grid_column: Line<GridPlacement>,\r\n}\r\n\r\nimpl Default for LayoutStyle {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        LayoutStyle {\r\n            display: Display::Flex,\r\n            overflow: (Overflow::Visible, Overflow::Visible),\r\n            scrollbar_width: 0.0,\r\n            position: Position::Relative,\r\n            inset: Rect::auto(),\r\n            margin: Rect::zero(),\r\n            padding: Rect::zero(),\r\n            border: Rect::zero(),\r\n            size: Vector2::new(Dimension::auto(), Dimension::auto()),\r\n            min_size: Vector2::new(Dimension::auto(), Dimension::auto()),\r\n            max_size: Vector2::new(Dimension::auto(), Dimension::auto()),\r\n            aspect_ratio: None,\r\n            gap: Vector2::new(LengthPercentage::length(0.0), LengthPercentage::length(0.0)),\r\n            align_items: None,\r\n            align_self: None,\r\n            justify_items: None,\r\n            justify_self: None,\r\n            align_content: None,\r\n            justify_content: None,\r\n            flex_direction: FlexDirection::Row,\r\n            flex_wrap: FlexWrap::NoWrap,\r\n            flex_grow: 0.0,\r\n            flex_shrink: 1.0,\r\n            flex_basis: Dimension::auto(),\r\n            grid_auto_flow: GridAutoFlow::Row,\r\n            grid_row: Line {\r\n                start: GridPlacement::Auto,\r\n                end: GridPlacement::Auto,\r\n            },\r\n            grid_column: Line {\r\n                start: GridPlacement::Auto,\r\n                end: GridPlacement::Auto,\r\n            },\r\n        }\r\n    }\r\n}\r\n\r\nimpl From<LayoutStyle> for taffy::Style {\r\n    #[inline(always)]\r\n    fn from(value: LayoutStyle) -> Self {\r\n        taffy::Style {\r\n            display: value.display,\r\n            overflow: taffy::Point {\r\n                x: value.overflow.0,\r\n                y: value.overflow.1,\r\n            },\r\n            scrollbar_width: value.scrollbar_width,\r\n            position: value.position,\r\n            inset: value.inset,\r\n            margin: value.margin,\r\n            padding: value.padding,\r\n            border: value.border,\r\n            size: taffy::Size {\r\n                width: value.size.x,\r\n                height: value.size.y,\r\n            },\r\n            min_size: taffy::Size {\r\n                width: value.min_size.x,\r\n                height: value.min_size.y,\r\n            },\r\n            max_size: taffy::Size {\r\n                width: value.max_size.x,\r\n                height: value.max_size.y,\r\n            },\r\n            aspect_ratio: value.aspect_ratio,\r\n            gap: taffy::Size {\r\n                width: value.gap.x,\r\n                height: value.gap.y,\r\n            },\r\n            align_items: value.align_items,\r\n            align_self: value.align_self,\r\n            justify_items: value.justify_items,\r\n            justify_self: value.justify_self,\r\n            align_content: value.align_content,\r\n            justify_content: value.justify_content,\r\n            flex_direction: value.flex_direction,\r\n            flex_wrap: value.flex_wrap,\r\n            flex_grow: value.flex_grow,\r\n            flex_shrink: value.flex_shrink,\r\n            flex_basis: value.flex_basis,\r\n            grid_auto_flow: value.grid_auto_flow,\r\n            grid_row: value.grid_row,\r\n            grid_column: value.grid_column,\r\n            ..Default::default()\r\n        }\r\n    }\r\n}\r\n\r\n/// The computed layout with children nodes.\r\n#[derive(Debug)]\r\npub struct LayoutNode {\r\n    /// The computed layout of this node.\r\n    pub layout: Layout,\r\n    /// The children of this node.\r\n    pub children: Vec<LayoutNode>,\r\n}\r\n\r\n/// The raw layout styles with children nodes.\r\npub struct StyleNode {\r\n    /// The layout style of this node.\r\n    pub style: LayoutStyle,\r\n    /// The children of this node.\r\n    pub children: Vec<StyleNode>,\r\n}\r\n\r\n#[cfg(all(test, feature = \"test\"))]\r\nmod tests {\r\n    use crate::layout::{equal, intersects};\r\n    use nalgebra::Vector2;\r\n    use taffy::{Layout, Point, Size};\r\n\r\n    /// Test the [equal] function.\r\n    #[test_case::test_case(1.0, 1.0, true; \"when equal and true\")]\r\n    #[test_case::test_case(12.0, 12.4, true; \"when positive and true\")]\r\n    #[test_case::test_case(123.0, 123.5, false; \"when positive and false\")]\r\n    #[test_case::test_case(-1234.0, -1234.4, true; \"when negative and true\")]\r\n    #[test_case::test_case(-10.0, -10.5, false; \"when negative and false\")]\r\n    #[test_case::test_case(-1.0, 0.3, false; \"when different and true\")]\r\n    #[test_case::test_case(-0.25, 0.25, false; \"when different and false\")]\r\n    fn test_equal(x: f32, y: f32, eq: bool) {\r\n        assert_eq!(equal(x, y), eq);\r\n    }\r\n\r\n    /// Test the [intersects] function.\r\n    #[test_case::test_case(100.0, 500.0, true; \"when point is on border\")]\r\n    #[test_case::test_case(150.0, 550.0, true; \"when point is inside\")]\r\n    #[test_case::test_case(700.0, 700.0, false; \"when point is outside\")]\r\n    fn test_intersects(x: f32, y: f32, eq: bool) {\r\n        let layout = Layout {\r\n            location: Point { x: 100.0, y: 500.0 },\r\n            size: Size {\r\n                width: 500.0,\r\n                height: 100.0,\r\n            },\r\n            ..Default::default()\r\n        };\r\n\r\n        assert_eq!(intersects(Vector2::new(x, y), &layout), eq);\r\n    }\r\n}\r\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":38,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":59,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":60,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":282,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":289,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":291,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":292,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":299,"address":[],"length":0,"stats":{"Line":1297036692682702848}}],"covered":13,"coverable":54},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","lib.rs"],"content":"#![warn(missing_docs)]\r\n\r\n//! Core library for Maycoon => See `maycoon` crate.\r\n//!\r\n//! Contains core app logic and widget types.\r\n\r\n/// Contains useful types for interacting with winit.\r\npub mod window {\r\n    pub use winit::event::*;\r\n    pub use winit::event_loop::*;\r\n    pub use winit::keyboard::*;\r\n    pub use winit::window::*;\r\n}\r\n\r\n/// Contains app functionality.\r\npub mod app;\r\n\r\n/// Contains the [MayConfig](config::MayConfig) struct.\r\npub mod config;\r\n\r\n/// Contains useful types and functions for layout interaction.\r\npub mod layout;\r\n\r\n/// Contains the signal system for reactive programming.\r\npub mod signal;\r\n\r\n/// Contains the core widget functionalities.\r\npub mod widget;\r\n\r\n/// Contains structures to work with the component architecture.\r\npub mod component;\r\n\r\n/// Contains the task runner and utilities for running async.\r\npub mod tasks;\r\n\r\n/// Contains the [reference::Ref] for representing a reference to a value.\r\npub mod reference;\r\n\r\n/// Contains the plugin system.\r\npub mod plugin;\r\n\r\n/// Contains the universal vector graphics interface.\r\npub mod vgi;\r\n\r\n/// Contains conditional types to provide generic platform specific structures.\r\npub mod platform;\r\n\r\n/// The data of the default Noto Sans font.\r\npub const DEFAULT_FONT: &[u8] = include_bytes!(\"NotoSans.ttf\");\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","platform.rs"],"content":"/// Contains [Instant](Instant) and [SystemTime](SystemTime) types for the web (using [web_time]).\r\n#[cfg(web)]\r\npub mod time {\r\n    pub use web_time::Instant;\r\n    pub use web_time::SystemTime;\r\n    pub use web_time::SystemTimeError;\r\n}\r\n\r\n/// Contains native [Instant] and [SystemTime] types.\r\n#[cfg(native)]\r\npub mod time {\r\n    pub use std::time::Instant;\r\n    pub use std::time::SystemTime;\r\n    pub use std::time::SystemTimeError;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","plugin.rs"],"content":"use crate::app::info::AppInfo;\r\nuse crate::app::update::UpdateManager;\r\nuse crate::config::MayConfig;\r\nuse crate::vgi::VectorGraphicsInterface;\r\nuse maycoon_theme::theme::Theme;\r\nuse rpds::HashTrieMap;\r\nuse std::cell::RefCell;\r\nuse std::ops::DerefMut;\r\nuse std::rc::Rc;\r\nuse std::sync::Arc;\r\nuse taffy::{NodeId, TaffyTree};\r\nuse winit::event::WindowEvent;\r\nuse winit::event_loop::{ActiveEventLoop, EventLoop};\r\nuse winit::window::{Window, WindowAttributes};\r\n\r\n/// A plugin interface for maycoon applications.\r\n///\r\n/// Plugins are used to extend functionality and manipulate the inner state of applications.\r\n/// Beware that tampering with the application state may cause crashes or other issues if not done correctly.\r\n///\r\n/// All functions defined in this trait get called before the app handler logic and therefore can control the application flow.\r\npub trait Plugin<T: Theme, V: VectorGraphicsInterface>: 'static {\r\n    /// The plugin name.\r\n    ///\r\n    /// Should be unique among the ecosystem.\r\n    fn name(&self) -> &'static str;\r\n\r\n    /// Called when the plugin is registered using [PluginManager::register].\r\n    fn on_register(&mut self, _manager: &mut PluginManager<T, V>) {}\r\n\r\n    /// Called when the plugin is unregistered using [PluginManager::unregister].\r\n    fn on_unregister(&mut self, _manager: &mut PluginManager<T, V>) {}\r\n\r\n    /// Called right before initializing the [AppHandler](crate::app::handler::AppHandler) and running the event loop.\r\n    #[inline(always)]\r\n    fn init(\r\n        &mut self,\r\n        _event_loop: &mut EventLoop<()>,\r\n        _update: &UpdateManager,\r\n        _window: &mut WindowAttributes,\r\n        _config: &mut MayConfig<T, V>,\r\n    ) {\r\n    }\r\n\r\n    /// Called when the application is resumed after being suspended or when it's first started.\r\n    ///\r\n    /// Desktop applications typically don't get suspended and this function is only called once,\r\n    /// while mobile apps can be suspended and resumed.\r\n    #[inline(always)]\r\n    fn on_resume(\r\n        &mut self,\r\n        _config: &mut MayConfig<T, V>,\r\n        _scene: &mut V::Scene,\r\n        _taffy: &mut TaffyTree,\r\n        _window_node: NodeId,\r\n        _info: &mut AppInfo,\r\n        _update: &UpdateManager,\r\n        _event_loop: &ActiveEventLoop,\r\n    ) {\r\n    }\r\n\r\n    /// Called right before the application handler tries to update the application\r\n    /// and figure out what updates to apply.\r\n    #[inline(always)]\r\n    fn on_update(\r\n        &mut self,\r\n        _config: &mut MayConfig<T, V>,\r\n        _window: &Arc<Window>,\r\n        _scene: &mut V::Scene,\r\n        _taffy: &mut TaffyTree,\r\n        _window_node: NodeId,\r\n        _info: &mut AppInfo,\r\n        _update: &UpdateManager,\r\n        _event_loop: &ActiveEventLoop,\r\n    ) {\r\n    }\r\n\r\n    /// Called when a window event is received.\r\n    #[inline(always)]\r\n    fn on_window_event(\r\n        &mut self,\r\n        _event: &mut WindowEvent,\r\n        _config: &mut MayConfig<T, V>,\r\n        _window: &Arc<Window>,\r\n        _scene: &mut V::Scene,\r\n        _taffy: &mut TaffyTree,\r\n        _window_node: NodeId,\r\n        _info: &mut AppInfo,\r\n        _update: &UpdateManager,\r\n        _event_loop: &ActiveEventLoop,\r\n    ) {\r\n    }\r\n\r\n    /// Called when the application is suspended.\r\n    #[cold]\r\n    fn on_suspended(\r\n        &mut self,\r\n        _config: &mut MayConfig<T, V>,\r\n        _scene: &mut V::Scene,\r\n        _taffy: &mut TaffyTree,\r\n        _window_node: NodeId,\r\n        _info: &mut AppInfo,\r\n        _update: &UpdateManager,\r\n        _event_loop: &ActiveEventLoop,\r\n    ) {\r\n    }\r\n}\r\n\r\n/// A plugin manager for maycoon applications.\r\npub struct PluginManager<T: Theme, V: VectorGraphicsInterface> {\r\n    plugins: HashTrieMap<&'static str, Rc<RefCell<dyn Plugin<T, V>>>>,\r\n}\r\n\r\nimpl<T: Theme, V: VectorGraphicsInterface> PluginManager<T, V> {\r\n    /// Creates a new empty plugin manager.\r\n    #[inline(always)]\r\n    pub fn new() -> Self {\r\n        Self {\r\n            plugins: HashTrieMap::new(),\r\n        }\r\n    }\r\n\r\n    /// Registers a new plugin and returns itself.\r\n    #[inline(always)]\r\n    pub fn register(mut self, mut plugin: impl Plugin<T, V>) -> Self {\r\n        plugin.on_register(&mut self);\r\n\r\n        Self {\r\n            plugins: self\r\n                .plugins\r\n                .insert(plugin.name(), Rc::new(RefCell::new(plugin))),\r\n        }\r\n    }\r\n\r\n    /// Unregisters a plugin and returns itself.\r\n    #[cold]\r\n    pub fn unregister(mut self, name: &'static str) -> Self {\r\n        let plugins = self.plugins.clone();\r\n\r\n        plugins\r\n            .get(name)\r\n            .expect(\"Plugin not found\")\r\n            .borrow_mut()\r\n            .on_unregister(&mut self);\r\n\r\n        Self {\r\n            plugins: self.plugins.remove(name),\r\n        }\r\n    }\r\n\r\n    /// Unregisters all plugins.\r\n    #[cold]\r\n    pub fn clear(&mut self) {\r\n        let plugins = self.plugins.clone();\r\n\r\n        for (_, pl) in plugins.iter() {\r\n            pl.borrow_mut().on_unregister(self);\r\n        }\r\n\r\n        self.plugins = HashTrieMap::new();\r\n    }\r\n\r\n    /// Runs a closure on all plugins.\r\n    #[inline(always)]\r\n    pub fn run<F>(&mut self, mut op: F)\r\n    where\r\n        F: FnMut(&mut dyn Plugin<T, V>),\r\n    {\r\n        for (_, plugin) in self.plugins.iter() {\r\n            let mut plugin = plugin.borrow_mut();\r\n\r\n            op(plugin.deref_mut());\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T: Theme, V: VectorGraphicsInterface> Default for PluginManager<T, V> {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self::new()\r\n    }\r\n}\r\n\r\n#[cfg(all(test, feature = \"test\"))]\r\nmod tests {\r\n    use crate::plugin::{Plugin, PluginManager};\r\n    use crate::vgi::dummy::DummyGraphics;\r\n    use maycoon_theme::theme::dummy::DummyTheme;\r\n    use std::sync::atomic::{AtomicU32, Ordering};\r\n\r\n    static A: AtomicU32 = AtomicU32::new(0);\r\n    static B: AtomicU32 = AtomicU32::new(0);\r\n    static C: AtomicU32 = AtomicU32::new(0);\r\n\r\n    /// Tests if plugin manager operates correctly on multiple plugins.\r\n    #[test]\r\n    fn test_plugin_manager() {\r\n        let mut plugins = PluginManager::<DummyTheme, DummyGraphics>::new()\r\n            .register(TestPluginA)\r\n            .register(TestPluginB)\r\n            .register(TestPluginC);\r\n\r\n        let mut run_a = 0;\r\n        let mut run_b = 0;\r\n        let mut run_c = 0;\r\n\r\n        plugins.run(|pl| match pl.name() {\r\n            \"Test Plugin A\" => run_a += 1,\r\n            \"Test Plugin B\" => run_b += 1,\r\n            \"Test Plugin C\" => run_c += 1,\r\n            _ => panic!(),\r\n        });\r\n\r\n        assert_eq!(run_a, 1);\r\n        assert_eq!(run_b, 1);\r\n        assert_eq!(run_c, 1);\r\n\r\n        plugins\r\n            .unregister(<TestPluginA as Plugin<DummyTheme, DummyGraphics>>::name(\r\n                &TestPluginA,\r\n            ))\r\n            .unregister(<TestPluginB as Plugin<DummyTheme, DummyGraphics>>::name(\r\n                &TestPluginB,\r\n            ))\r\n            .unregister(<TestPluginC as Plugin<DummyTheme, DummyGraphics>>::name(\r\n                &TestPluginC,\r\n            ));\r\n\r\n        assert_eq!(A.load(Ordering::Relaxed), 11);\r\n        assert_eq!(B.load(Ordering::Relaxed), 11);\r\n        assert_eq!(C.load(Ordering::Relaxed), 11);\r\n    }\r\n\r\n    struct TestPluginA;\r\n\r\n    impl Plugin<DummyTheme, DummyGraphics> for TestPluginA {\r\n        fn name(&self) -> &'static str {\r\n            \"Test Plugin A\"\r\n        }\r\n\r\n        fn on_register(&mut self, _manager: &mut PluginManager<DummyTheme, DummyGraphics>) {\r\n            A.fetch_add(1, Ordering::Relaxed);\r\n        }\r\n\r\n        fn on_unregister(&mut self, _manager: &mut PluginManager<DummyTheme, DummyGraphics>) {\r\n            A.fetch_add(10, Ordering::Relaxed);\r\n        }\r\n    }\r\n\r\n    struct TestPluginB;\r\n\r\n    impl Plugin<DummyTheme, DummyGraphics> for TestPluginB {\r\n        fn name(&self) -> &'static str {\r\n            \"Test Plugin B\"\r\n        }\r\n\r\n        fn on_register(&mut self, _manager: &mut PluginManager<DummyTheme, DummyGraphics>) {\r\n            B.fetch_add(1, Ordering::Relaxed);\r\n        }\r\n\r\n        fn on_unregister(&mut self, _manager: &mut PluginManager<DummyTheme, DummyGraphics>) {\r\n            B.fetch_add(10, Ordering::Relaxed);\r\n        }\r\n    }\r\n\r\n    struct TestPluginC;\r\n\r\n    impl Plugin<DummyTheme, DummyGraphics> for TestPluginC {\r\n        fn name(&self) -> &'static str {\r\n            \"Test Plugin C\"\r\n        }\r\n\r\n        fn on_register(&mut self, _manager: &mut PluginManager<DummyTheme, DummyGraphics>) {\r\n            C.fetch_add(1, Ordering::Relaxed);\r\n        }\r\n\r\n        fn on_unregister(&mut self, _manager: &mut PluginManager<DummyTheme, DummyGraphics>) {\r\n            C.fetch_add(10, Ordering::Relaxed);\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":119,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":125,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":126,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":129,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":137,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":138,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":140,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":141,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":144,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":147,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":169,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":170,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":172,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":238,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":241,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":242,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":245,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":246,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":253,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":254,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":257,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":258,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":261,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":262,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":269,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":270,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":273,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":274,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":277,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":278,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":33,"coverable":47},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","reference.rs"],"content":"use std::ops::Deref;\r\nuse std::sync::RwLockReadGuard;\r\n\r\n/// Represents a reference to a value of type `T`.\r\n///\r\n/// Due to Rust's temporal borrowing rules,\r\n/// returning a reference to a value may not be always possible,\r\n/// so this enum is used to represent one by having multiple variants for multiple types of references.\r\npub enum Ref<'a, T> {\r\n    /// An owned value. Useful for [Copy] types.\r\n    Owned(T),\r\n    /// A borrowed reference.\r\n    Borrow(&'a T),\r\n    /// A reference of a [std::cell::Ref].\r\n    Ref(std::cell::Ref<'a, T>),\r\n    /// A [RwLockReadGuard] reference.\r\n    ReadGuard(RwLockReadGuard<'a, T>),\r\n}\r\n\r\nimpl<'a, T> Deref for Ref<'a, T> {\r\n    type Target = T;\r\n\r\n    #[inline(always)]\r\n    fn deref(&self) -> &Self::Target {\r\n        match self {\r\n            Ref::Owned(value) => value,\r\n            Ref::Borrow(value) => value,\r\n            Ref::Ref(value) => value,\r\n            Ref::ReadGuard(value) => value,\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a, T> From<T> for Ref<'a, T> {\r\n    #[inline(always)]\r\n    fn from(value: T) -> Self {\r\n        Ref::Owned(value)\r\n    }\r\n}\r\n\r\nimpl<'a, T> From<&'a T> for Ref<'a, T> {\r\n    #[inline(always)]\r\n    fn from(value: &'a T) -> Self {\r\n        Ref::Borrow(value)\r\n    }\r\n}\r\n\r\nimpl<'a, T> From<std::cell::Ref<'a, T>> for Ref<'a, T> {\r\n    #[inline(always)]\r\n    fn from(value: std::cell::Ref<'a, T>) -> Self {\r\n        Ref::Ref(value)\r\n    }\r\n}\r\n\r\nimpl<'a, T> From<RwLockReadGuard<'a, T>> for Ref<'a, T> {\r\n    #[inline(always)]\r\n    fn from(value: RwLockReadGuard<'a, T>) -> Self {\r\n        Ref::ReadGuard(value)\r\n    }\r\n}\r\n\r\n#[cfg(all(test, feature = \"test\"))]\r\nmod tests {\r\n    use crate::reference::Ref;\r\n    use std::cell::RefCell;\r\n    use std::fmt::Debug;\r\n    use std::sync::RwLock;\r\n\r\n    #[test_case::test_case(1; \"with int\")]\r\n    #[test_case::test_case(\"Test\".to_string(); \"with string\")]\r\n    #[test_case::test_case(vec![1, 2, 3]; \"with vector\")]\r\n    fn test_ref<T: Clone + PartialEq + Debug>(value: T) {\r\n        let r_bor = Ref::Borrow(&value);\r\n        assert_eq!(*r_bor, value);\r\n\r\n        let r_own = Ref::Owned(value.clone());\r\n        assert_eq!(*r_own, value);\r\n\r\n        let refcell = RefCell::new(value.clone());\r\n        let r_ref = Ref::Ref(refcell.borrow());\r\n        assert_eq!(*r_ref, value);\r\n\r\n        let rwlock = RwLock::new(value.clone());\r\n        let r_rw = Ref::ReadGuard(rwlock.read().unwrap());\r\n        assert_eq!(*r_rw, value);\r\n    }\r\n\r\n    /// Tests if the size of [Ref] is correct.\r\n    ///\r\n    /// Useful for not accidentally increasing the stack size of [Ref].\r\n    #[test]\r\n    fn test_ref_size() {\r\n        const SIZE: usize = 24;\r\n\r\n        assert_eq!(size_of::<Ref<'_, u8>>(), SIZE);\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":25,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":26,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":73,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":74,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":79,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":80,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":81,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":83,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":84,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":85,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":17,"coverable":25},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","signal","eval.rs"],"content":"use crate::reference::Ref;\r\nuse crate::signal::Signal;\r\nuse std::rc::Rc;\r\n\r\n/// A signal that evaluates a function to get the value.\r\n///\r\n/// The evaluation function will be called every time the value is requested via [Signal::get],\r\n/// so it's recommended to avoid expensive operations.\r\npub struct EvalSignal<T: 'static> {\r\n    eval: Rc<dyn Fn() -> T>,\r\n}\r\n\r\nimpl<T: 'static> EvalSignal<T> {\r\n    /// Create a new eval signal using the given evaluation function.\r\n    #[inline(always)]\r\n    pub fn new(eval: impl Fn() -> T + 'static) -> Self {\r\n        Self {\r\n            eval: Rc::new(eval),\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Signal<T> for EvalSignal<T> {\r\n    #[inline(always)]\r\n    fn get(&self) -> Ref<'_, T> {\r\n        Ref::Owned((self.eval)())\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn set_value(&self, _: T) {}\r\n\r\n    #[inline(always)]\r\n    fn listen(self, _: Box<dyn Fn(Ref<'_, T>)>) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn notify(&self) {}\r\n\r\n    #[inline(always)]\r\n    fn dyn_clone(&self) -> Box<dyn Signal<T>> {\r\n        Box::new(self.clone())\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Clone for EvalSignal<T> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            eval: self.eval.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(all(test, feature = \"test\"))]\r\nmod tests {\r\n    use crate::signal::Signal;\r\n    use crate::signal::eval::EvalSignal;\r\n    use std::cell::RefCell;\r\n    use std::rc::Rc;\r\n\r\n    /// Tests the [EvalSignal] implementation of [Signal].\r\n    #[test]\r\n    fn test_eval_signal() {\r\n        let value = Rc::new(RefCell::new(0));\r\n\r\n        let value_clone = value.clone();\r\n        let signal = EvalSignal::new(move || {\r\n            *value_clone.borrow_mut() += 1;\r\n            *value_clone.borrow()\r\n        });\r\n\r\n        // signal = value = 1\r\n        assert_eq!(*signal.get(), 1);\r\n        assert_eq!(*value.borrow(), 1);\r\n\r\n        // signal = value = 2\r\n        assert_eq!(*signal.get(), 2);\r\n        assert_eq!(*value.borrow(), 2);\r\n\r\n        // signal = value = 3\r\n        assert_eq!(*signal.get(), 3);\r\n        assert_eq!(*value.borrow(), 3);\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":26,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":12},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","signal","fixed.rs"],"content":"use crate::signal::{Ref, Signal};\r\nuse std::rc::Rc;\r\n\r\n/// A signal with a fixed value. Based on [Rc].\r\n///\r\n/// The inner value cannot be mutated and listeners do not exist.\r\n///\r\n/// Useful for testing purposes, but also used in `MaybeSignal::into_signal` to convert a fixed value into a signal.\r\npub struct FixedSignal<T: 'static> {\r\n    value: Rc<T>,\r\n}\r\n\r\nimpl<T: 'static> FixedSignal<T> {\r\n    /// Creates a new fixed signal.\r\n    #[inline(always)]\r\n    pub fn new(value: T) -> Self {\r\n        Self {\r\n            value: Rc::new(value),\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Signal<T> for FixedSignal<T> {\r\n    #[inline(always)]\r\n    fn get(&self) -> Ref<'_, T> {\r\n        Ref::Borrow(self.value.as_ref())\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn set_value(&self, _: T) {}\r\n\r\n    #[inline(always)]\r\n    fn listen(self, _: Box<dyn Fn(Ref<'_, T>)>) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn notify(&self) {}\r\n\r\n    #[inline(always)]\r\n    fn dyn_clone(&self) -> Box<dyn Signal<T>> {\r\n        Box::new(self.clone())\r\n    }\r\n}\r\n\r\nimpl<T: 'static> From<Rc<T>> for FixedSignal<T> {\r\n    #[inline(always)]\r\n    fn from(value: Rc<T>) -> Self {\r\n        Self { value }\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Clone for FixedSignal<T> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            value: self.value.clone(),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":45,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":60,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":8,"coverable":13},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","signal","listener.rs"],"content":"use crate::reference::Ref;\r\nuse rpds::{Vector, VectorSync};\r\nuse std::rc::Rc;\r\nuse std::sync::Arc;\r\n\r\n/// A collection of listeners.\r\n///\r\n/// This is basically just a wrapper around `Vec<Listener<T>>>`.\r\npub struct ListenerRegister<T> {\r\n    listeners: Vector<Listener<T>>,\r\n}\r\n\r\nimpl<T> ListenerRegister<T> {\r\n    /// Create a new empty listener register.\r\n    ///\r\n    /// By default, the listener register has a capacity of 1,\r\n    /// meaning that it can hold one listener without reallocating.\r\n    #[inline(always)]\r\n    pub fn new() -> Self {\r\n        Self {\r\n            listeners: Vector::new(),\r\n        }\r\n    }\r\n\r\n    /// Register a new listener.\r\n    #[inline(always)]\r\n    pub fn register(self, listener: Listener<T>) -> Self {\r\n        Self {\r\n            listeners: self.listeners.push_back(listener),\r\n        }\r\n    }\r\n\r\n    /// Notify all listeners with the values produced by `factory`.\r\n    #[inline(always)]\r\n    pub fn notify<'a>(&self, factory: impl Fn() -> Ref<'a, T>)\r\n    where\r\n        T: 'a,\r\n    {\r\n        for listener in &self.listeners {\r\n            listener.call(factory());\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T> Default for ListenerRegister<T> {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self::new()\r\n    }\r\n}\r\n\r\nimpl<T> Clone for ListenerRegister<T> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            listeners: self.listeners.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n/// A collection of listeners that can be sent to other threads.\r\n///\r\n/// This is basically just a wrapper around `Vec<SendListener<T>>>`.\r\npub struct SendListenerRegistry<T> {\r\n    listeners: VectorSync<SendListener<T>>,\r\n}\r\n\r\nimpl<T> SendListenerRegistry<T> {\r\n    /// Create a new empty listener register.\r\n    ///\r\n    /// By default, the listener register has a capacity of 1,\r\n    /// meaning that it can hold one listener without reallocating.\r\n    #[inline(always)]\r\n    pub fn new() -> Self {\r\n        Self {\r\n            listeners: VectorSync::new_sync(),\r\n        }\r\n    }\r\n\r\n    /// Register a new listener.\r\n    #[inline(always)]\r\n    pub fn register(self, listener: SendListener<T>) -> Self {\r\n        Self {\r\n            listeners: self.listeners.push_back(listener),\r\n        }\r\n    }\r\n\r\n    /// Notify all listeners with the values produced by `factory`.\r\n    #[inline(always)]\r\n    pub fn notify<'a>(&self, factory: impl Fn() -> Ref<'a, T>)\r\n    where\r\n        T: 'a,\r\n    {\r\n        for listener in &self.listeners {\r\n            listener.call(factory());\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T> Default for SendListenerRegistry<T> {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self::new()\r\n    }\r\n}\r\n\r\nimpl<T> Clone for SendListenerRegistry<T> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            listeners: self.listeners.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n/// A listener that listens to a signal value.\r\n///\r\n/// This is basically just a wrapper around `Rc<dyn Fn(Ref<'_, T>)>>`.\r\n///\r\n/// This type is not `Send` and therefore cannot be sent to other threads.\r\n///\r\n/// It trades less overhead for not being `Send`.\r\n///\r\n/// Use [SendListener] if you need a `Send`-safe listener.\r\npub struct Listener<T> {\r\n    function: Rc<dyn Fn(Ref<'_, T>)>,\r\n}\r\n\r\nimpl<T> Listener<T> {\r\n    /// Create a new listener.\r\n    #[inline(always)]\r\n    pub fn new(function: impl Fn(Ref<'_, T>) + 'static) -> Self {\r\n        Self {\r\n            function: Rc::new(function),\r\n        }\r\n    }\r\n\r\n    /// Create a new listener from a raw reference counted function.\r\n    #[inline(always)]\r\n    pub fn from_rc(function: Rc<dyn Fn(Ref<'_, T>)>) -> Self {\r\n        Self { function }\r\n    }\r\n\r\n    /// Call the listener with a value.\r\n    #[inline(always)]\r\n    pub fn call(&self, value: Ref<'_, T>) {\r\n        (self.function)(value)\r\n    }\r\n}\r\n\r\nimpl<T> Default for Listener<T> {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self {\r\n            function: Rc::new(|_| {}),\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T> Clone for Listener<T> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            function: self.function.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n/// A listener that listens to a signal value.\r\n///\r\n/// This is basically just a wrapper around `Arc<dyn Fn(Ref<'_, T>)>>`.\r\n///\r\n/// This type is `Send` and therefore can be sent to other threads.\r\n///\r\n/// It trades more overhead for being `Send`.\r\n///\r\n/// Use [Listener] if you don't need a `Send`-safe listener.\r\npub struct SendListener<T> {\r\n    function: Arc<dyn Fn(Ref<'_, T>)>,\r\n}\r\n\r\nimpl<T> SendListener<T> {\r\n    /// Create a new listener.\r\n    #[inline(always)]\r\n    pub fn new(function: impl Fn(Ref<'_, T>) + 'static) -> Self {\r\n        Self {\r\n            function: Arc::new(function),\r\n        }\r\n    }\r\n\r\n    /// Create a new listener from a raw atomically reference counted function.\r\n    #[inline(always)]\r\n    pub fn from_arc(function: Arc<dyn Fn(Ref<'_, T>)>) -> Self {\r\n        Self { function }\r\n    }\r\n\r\n    /// Call the listener with a value.\r\n    #[inline(always)]\r\n    pub fn call(&self, value: Ref<'_, T>) {\r\n        (self.function)(value)\r\n    }\r\n}\r\n\r\nimpl<T> Default for SendListener<T> {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self {\r\n            function: Arc::new(|_| {}),\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T> Clone for SendListener<T> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            function: self.function.clone(),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":39,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":40,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":134,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}}],"covered":9,"coverable":40},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","signal","map.rs"],"content":"use crate::signal::{BoxedSignal, Ref, Signal};\r\nuse std::rc::Rc;\r\n\r\n/// A signal wrapping another signal and applying a mapping function, when the inner value is requested.\r\n/// The mapping function will be called every time the inner value is requested via [Signal::get].\r\n/// This signal cannot be directly mutated. Use [MapSignal::signal] to get the inner signal.\r\n///\r\n/// Calling [Signal::set], [Signal::set_value], [Signal::listen] has no effect.\r\npub struct MapSignal<T: 'static, U: 'static> {\r\n    signal: BoxedSignal<T>,\r\n    map: Rc<dyn Fn(Ref<T>) -> Ref<U>>,\r\n}\r\n\r\nimpl<T: 'static, U: 'static> MapSignal<T, U> {\r\n    /// Create a new map signal using the given inner signal and mapping function.\r\n    #[inline(always)]\r\n    pub fn new(signal: BoxedSignal<T>, map: impl Fn(Ref<T>) -> Ref<U> + 'static) -> Self {\r\n        Self {\r\n            signal,\r\n            map: Rc::new(map),\r\n        }\r\n    }\r\n\r\n    /// Get the inner signal.\r\n    ///\r\n    /// Can be used to mutate the inner value.\r\n    #[inline(always)]\r\n    pub fn signal(&self) -> BoxedSignal<T> {\r\n        self.signal.dyn_clone()\r\n    }\r\n\r\n    /// Get the inner signal's value, without applying the mapping function.\r\n    #[inline(always)]\r\n    pub fn get_unmapped(&self) -> Ref<'_, T> {\r\n        self.signal.get()\r\n    }\r\n}\r\n\r\nimpl<T: 'static, U: 'static> Signal<U> for MapSignal<T, U> {\r\n    #[inline(always)]\r\n    fn get(&self) -> Ref<'_, U> {\r\n        (self.map)(self.get_unmapped())\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn set_value(&self, _: U) {}\r\n\r\n    #[inline(always)]\r\n    fn listen(self, _: Box<dyn Fn(Ref<'_, U>)>) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn notify(&self) {\r\n        self.signal.notify();\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn dyn_clone(&self) -> Box<dyn Signal<U>> {\r\n        Box::new(self.clone())\r\n    }\r\n}\r\n\r\nimpl<T: 'static, U: 'static> Clone for MapSignal<T, U> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            signal: self.signal.dyn_clone(),\r\n            map: self.map.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(all(test, feature = \"test\"))]\r\nmod tests {\r\n    use crate::reference::Ref;\r\n    use crate::signal::Signal;\r\n    use crate::signal::fixed::FixedSignal;\r\n\r\n    /// Tests the [MapSignal] implementation of [Signal].\r\n    #[test]\r\n    fn test_map_signal() {\r\n        let signal = FixedSignal::new(0)\r\n            .map(|i| Ref::Owned(i.to_string()))\r\n            .map(|s| Ref::Owned(s.len()))\r\n            .map(|len| Ref::Owned(len.to_string()));\r\n\r\n        assert_eq!(*signal.get(), \"1\".to_string());\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":41,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":42,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":63,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":69,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":72,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":11,"coverable":18},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","signal","memoized.rs"],"content":"use crate::reference::Ref;\r\nuse crate::signal::Signal;\r\nuse crate::signal::listener::{Listener, ListenerRegister};\r\nuse std::cell::OnceCell;\r\nuse std::rc::Rc;\r\n\r\n/// A signal for creating a value once, when requested.\r\n/// The value is immutable after creation.\r\n/// Calling [Signal::set], [Signal::set_value], [Signal::listen] or [Signal::notify] has no effect.\r\n///\r\n/// **NOTE:** The inner factory function will only be called **once**, when the value is requested via [Signal::get].\r\npub struct MemoizedSignal<T: 'static> {\r\n    inner: Rc<OnceCell<T>>,\r\n    factory: Rc<dyn Fn() -> T>,\r\n    listeners: ListenerRegister<T>,\r\n}\r\n\r\nimpl<T: 'static> MemoizedSignal<T> {\r\n    #[inline(always)]\r\n    /// Create a new memoized signal using the given factory function.\r\n    pub fn new(factory: impl Fn() -> T + 'static) -> Self {\r\n        Self {\r\n            inner: Rc::new(OnceCell::new()),\r\n            factory: Rc::new(factory),\r\n            listeners: ListenerRegister::new(),\r\n        }\r\n    }\r\n\r\n    /// Returns if the value has been initialized or not.\r\n    #[inline(always)]\r\n    pub fn is_init(&self) -> bool {\r\n        self.inner.get().is_some()\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Signal<T> for MemoizedSignal<T> {\r\n    #[inline(always)]\r\n    fn get(&self) -> Ref<'_, T> {\r\n        if !self.is_init() {\r\n            self.inner.set((self.factory)()).ok().unwrap();\r\n\r\n            self.notify();\r\n        }\r\n\r\n        Ref::Borrow(self.inner.get().unwrap())\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn set_value(&self, _: T) {}\r\n\r\n    #[inline(always)]\r\n    fn listen(self, listener: Box<dyn Fn(Ref<'_, T>)>) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        Self {\r\n            inner: self.inner,\r\n            factory: self.factory,\r\n            listeners: self.listeners.register(Listener::new(listener)),\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn notify(&self) {\r\n        self.listeners.notify(|| self.get());\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn dyn_clone(&self) -> Box<dyn Signal<T>> {\r\n        Box::new(self.clone())\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Clone for MemoizedSignal<T> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            inner: self.inner.clone(),\r\n            factory: self.factory.clone(),\r\n            listeners: self.listeners.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(all(test, feature = \"test\"))]\r\nmod tests {\r\n    use crate::signal::Signal;\r\n    use crate::signal::memoized::MemoizedSignal;\r\n    use std::cell::RefCell;\r\n    use std::rc::Rc;\r\n\r\n    /// Tests the [MemoizedSignal] implementation of [Signal].\r\n    #[test]\r\n    fn test_memoized_signal() {\r\n        let sum = Rc::new(RefCell::new(0));\r\n        let diff = Rc::new(RefCell::new(0));\r\n\r\n        let sum_clone = sum.clone();\r\n        let diff_clone = diff.clone();\r\n        let signal = MemoizedSignal::new(|| 1)\r\n            .listen(Box::new(move |val| {\r\n                *sum_clone.borrow_mut() += *val;\r\n            }))\r\n            .listen(Box::new(move |val| {\r\n                *diff_clone.borrow_mut() -= *val;\r\n            }));\r\n\r\n        // sum = 0\r\n        assert_eq!(*sum.borrow(), 0);\r\n        // diff = 0\r\n        assert_eq!(*diff.borrow(), 0);\r\n\r\n        // signal = 1\r\n        assert_eq!(*signal.get(), 1);\r\n\r\n        // sum = sum + signal = 0 + 1 = 1\r\n        assert_eq!(*sum.borrow(), 1);\r\n        // diff = diff - signal = 0 - 1 = -1\r\n        assert_eq!(*diff.borrow(), -1);\r\n    }\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":57,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":58,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":59,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":24},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","signal","mod.rs"],"content":"use crate::app::context::AppContext;\r\nuse crate::reference::Ref;\r\nuse crate::signal::fixed::FixedSignal;\r\nuse crate::signal::listener::Listener;\r\nuse crate::signal::map::MapSignal;\r\nuse std::rc::Rc;\r\n\r\n/// Contains the [FixedSignal] signal.\r\npub mod fixed;\r\n\r\n/// Contains the [memoized::MemoizedSignal] signal.\r\npub mod memoized;\r\n\r\n/// Contains the [state::StateSignal] signal.\r\npub mod state;\r\n\r\n/// Contains the [MapSignal] signal.\r\npub mod map;\r\n\r\n/// Contains the [eval::EvalSignal] signal.\r\npub mod eval;\r\n\r\n/// Contains the [Listener] listener.\r\npub mod listener;\r\n\r\n/// A [Signal] in a [Box].\r\npub type BoxedSignal<T> = Box<dyn Signal<T>>;\r\n\r\n/// Base signal trait.\r\n///\r\n/// Signals store values of type `T` and notify listeners when they change.\r\n///\r\n/// **NOTE:** By default, signals don't have any listeners. To \"hook\" a signal into the application cycle, call [use_signal].\r\n///\r\n/// # Avoiding Borrowing Errors\r\n/// Be careful not to write something like `signal.set(*signal.get());`,\r\n/// as many signals that use [Rc] or [RefCell] might panic, due to the value already being borrowed\r\n/// (by the `signal.get();` call). Write `let value = *signal.get();` or `let value = signal.clone()`\r\n/// and then `signal.set(value);` instead.\r\n///\r\n/// [use_signal]: AppContext::use_signal\r\n/// [RefCell]: std::cell::RefCell\r\npub trait Signal<T: 'static>: 'static {\r\n    /// Get a reference to the current value of the signal.\r\n    fn get(&self) -> Ref<'_, T>;\r\n\r\n    /// Set the value of the signal.\r\n    ///\r\n    /// **NOTE:** This does not notify listeners, use [set] instead.\r\n    fn set_value(&self, value: T);\r\n\r\n    /// Add a listener to the signal, which will be called when the inner value changes and returns the signal.\r\n    fn listen(self, listener: Box<dyn Fn(Ref<'_, T>)>) -> Self\r\n    where\r\n        Self: Sized;\r\n\r\n    /// Notify listeners that the inner value has changed.\r\n    /// May also be called manually to update listeners.\r\n    fn notify(&self);\r\n\r\n    /// Set the value of the signal and notify listeners.\r\n    #[inline(always)]\r\n    fn set(&self, value: T) {\r\n        tracing::trace_span!(\"set signal\").in_scope(|| {\r\n            self.set_value(value);\r\n            self.notify();\r\n        });\r\n    }\r\n\r\n    /// Converts the signal into a [MaybeSignal].\r\n    #[inline(always)]\r\n    fn maybe(&self) -> MaybeSignal<T>\r\n    where\r\n        Self: Sized,\r\n    {\r\n        MaybeSignal::signal(self.dyn_clone())\r\n    }\r\n\r\n    /// Converts this signal into a [MapSignal] and applies the given mapping function.\r\n    #[inline(always)]\r\n    fn map<U: 'static>(&self, map: impl Fn(Ref<T>) -> Ref<U> + 'static) -> MapSignal<T, U>\r\n    where\r\n        Self: Sized,\r\n    {\r\n        MapSignal::new(self.dyn_clone(), map)\r\n    }\r\n\r\n    /// Hooks the signal into the given [AppContext].\r\n    ///\r\n    /// Required for the signal to become reactive with the app lifecycle.\r\n    #[inline(always)]\r\n    fn hook(self, context: &AppContext) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        context.use_signal(self)\r\n    }\r\n\r\n    /// Clones the signal into a `Box<dyn Signal<T>>`.\r\n    ///\r\n    /// This is an object-safe alternative to simply making the signal [Clone]-dependent.\r\n    fn dyn_clone(&self) -> Box<dyn Signal<T>>;\r\n}\r\n\r\n/// A value which may be a signal or a fixed value.\r\npub enum MaybeSignal<T: 'static> {\r\n    /// A signal.\r\n    Signal(BoxedSignal<T>),\r\n    /// A fixed value wrapped inside a [Rc].\r\n    Value(Rc<T>),\r\n}\r\n\r\nimpl<T: 'static> MaybeSignal<T> {\r\n    /// Wrap a [Signal] inside a [MaybeSignal].\r\n    #[inline(always)]\r\n    pub const fn signal(signal: BoxedSignal<T>) -> Self {\r\n        Self::Signal(signal)\r\n    }\r\n\r\n    /// Wrap a value inside a [MaybeSignal].\r\n    #[inline(always)]\r\n    pub fn value(value: T) -> Self {\r\n        Self::Value(Rc::new(value))\r\n    }\r\n\r\n    /// Get a reference to the current value.\r\n    ///\r\n    /// If the value is a signal, the signal's current value is returned,\r\n    /// otherwise a [Ref::Rc] of the value is returned.\r\n    #[inline(always)]\r\n    pub fn get(&self) -> Ref<'_, T> {\r\n        match self {\r\n            MaybeSignal::Signal(signal) => signal.get(),\r\n            MaybeSignal::Value(value) => Ref::Borrow(value.as_ref()),\r\n        }\r\n    }\r\n\r\n    /// Converts the [MaybeSignal] into an [BoxedSignal] if it is a [MaybeSignal::Signal].\r\n    #[inline(always)]\r\n    pub fn as_signal(&self) -> Option<BoxedSignal<T>> {\r\n        match self {\r\n            MaybeSignal::Signal(signal) => Some(signal.dyn_clone()),\r\n            _ => None,\r\n        }\r\n    }\r\n\r\n    /// Converts the [MaybeSignal] into a [BoxedSignal].\r\n    ///\r\n    /// If the value is a [MaybeSignal::Value], a [FixedSignal] is created.\r\n    #[inline(always)]\r\n    pub fn into_signal(self) -> BoxedSignal<T> {\r\n        match self {\r\n            MaybeSignal::Signal(signal) => signal,\r\n            MaybeSignal::Value(value) => Box::new(FixedSignal::from(value)),\r\n        }\r\n    }\r\n\r\n    /// Applies the given mapping function to the signal.\r\n    ///\r\n    /// Returns a [MaybeSignal] containing a [MapSignal] which maps the inner value of the signal.\r\n    #[inline(always)]\r\n    pub fn map<U: 'static>(self, map: impl Fn(Ref<T>) -> Ref<U> + 'static) -> MaybeSignal<U> {\r\n        let signal = self.into_signal();\r\n\r\n        MaybeSignal::signal(Box::new(MapSignal::new(signal, map)))\r\n    }\r\n}\r\n\r\nimpl<T: Default + 'static> Default for MaybeSignal<T> {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self::value(T::default())\r\n    }\r\n}\r\n\r\nimpl<T: 'static> From<T> for MaybeSignal<T> {\r\n    #[inline(always)]\r\n    fn from(value: T) -> Self {\r\n        Self::value(value)\r\n    }\r\n}\r\n\r\nimpl<T: 'static> From<BoxedSignal<T>> for MaybeSignal<T> {\r\n    #[inline(always)]\r\n    fn from(signal: BoxedSignal<T>) -> Self {\r\n        Self::signal(signal)\r\n    }\r\n}\r\n\r\nimpl<'a, T: 'static> From<&'a BoxedSignal<T>> for MaybeSignal<T> {\r\n    #[inline(always)]\r\n    fn from(value: &'a BoxedSignal<T>) -> Self {\r\n        Self::signal(value.dyn_clone())\r\n    }\r\n}\r\n\r\nimpl<T: 'static, U: 'static> From<MapSignal<T, U>> for MaybeSignal<U> {\r\n    #[inline(always)]\r\n    fn from(value: MapSignal<T, U>) -> Self {\r\n        Self::signal(Box::new(value))\r\n    }\r\n}\r\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":64,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":65,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":85,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":39},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","signal","state.rs"],"content":"use crate::signal::listener::ListenerRegister;\r\nuse crate::signal::{Listener, Ref, Signal};\r\nuse std::cell::RefCell;\r\nuse std::rc::Rc;\r\n\r\n/// Simple signal implementation based on [Rc] and [RefCell] to get/set a value and notify listeners when it changes.\r\n///\r\n/// You can also mutate the inner value, but only in a set scope.\r\n///\r\n/// As this signal uses [RefCell], it's subject to possible runtime borrowing errors.\r\n/// See the section about these errors in [Signal] for more.\r\npub struct StateSignal<T: 'static> {\r\n    value: Rc<RefCell<T>>,\r\n    listeners: ListenerRegister<T>,\r\n}\r\n\r\nimpl<T: 'static> StateSignal<T> {\r\n    /// Creates a new signal with the given value.\r\n    #[inline(always)]\r\n    pub fn new(value: T) -> Self {\r\n        Self {\r\n            value: Rc::new(RefCell::new(value)),\r\n            listeners: ListenerRegister::new(),\r\n        }\r\n    }\r\n\r\n    /// Mutate the inner value in a set scope.\r\n    ///\r\n    /// This scope is needed in order to notify the app for changes.\r\n    #[inline(always)]\r\n    #[tracing::instrument(skip_all)]\r\n    pub fn mutate(&self, op: impl FnOnce(&mut T)) {\r\n        op(&mut self.value.borrow_mut());\r\n        self.notify();\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Signal<T> for StateSignal<T> {\r\n    #[inline(always)]\r\n    fn get(&self) -> Ref<'_, T> {\r\n        Ref::Ref(self.value.borrow())\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn set_value(&self, value: T) {\r\n        *self.value.borrow_mut() = value;\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn listen(self, listener: Box<dyn Fn(Ref<'_, T>)>) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        Self {\r\n            listeners: self.listeners.register(Listener::new(listener)),\r\n            ..self\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn notify(&self) {\r\n        self.listeners.notify(|| self.get());\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn dyn_clone(&self) -> Box<dyn Signal<T>> {\r\n        Box::new(self.clone())\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Clone for StateSignal<T> {\r\n    #[inline(always)]\r\n    fn clone(&self) -> Self {\r\n        Self {\r\n            value: self.value.clone(),\r\n            listeners: self.listeners.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(all(test, feature = \"test\"))]\r\nmod tests {\r\n    use crate::signal::Signal;\r\n    use crate::signal::state::StateSignal;\r\n    use std::cell::RefCell;\r\n    use std::rc::Rc;\r\n\r\n    /// Tests the [StateSignal] implementation of [Signal].\r\n    #[test]\r\n    fn test_state_signal() {\r\n        let sum = Rc::new(RefCell::new(0));\r\n        let diff = Rc::new(RefCell::new(0));\r\n\r\n        let sum_clone = sum.clone();\r\n        let diff_clone = diff.clone();\r\n        let signal = StateSignal::new(0)\r\n            .listen(Box::new(move |val| {\r\n                *sum_clone.borrow_mut() += *val;\r\n            }))\r\n            .listen(Box::new(move |val| {\r\n                *diff_clone.borrow_mut() -= *val;\r\n            }));\r\n\r\n        let value = *signal.get();\r\n\r\n        // value = value + 1 = 0 + 1 = 1\r\n        signal.set(value + 1);\r\n\r\n        // sum = sum + value = 0 + 1 = 1\r\n        assert_eq!(*sum.borrow(), 1);\r\n\r\n        // diff = sum - value = 0 - 1 = -1\r\n        assert_eq!(*diff.borrow(), -1);\r\n\r\n        // value = value - 1 = 1 - 1 = 0\r\n        signal.mutate(|val| {\r\n            *val -= 1;\r\n        });\r\n\r\n        // sum = sum + value = 1 + 0 = 1\r\n        assert_eq!(*sum.borrow(), 1);\r\n\r\n        // diff = diff + value = -1 + 0 = -1\r\n        assert_eq!(*diff.borrow(), -1);\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":55,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":62,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":19},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","tasks","fetcher.rs"],"content":"use crate::tasks::runner;\r\nuse crate::tasks::task::Task;\r\n\r\n/// A value factory that uses the result of an asynchronous task to compute an output value.\r\n///\r\n/// The fetcher takes a task and a factory function.\r\n/// It produces an output value `O` by taking an [Option] of an input value `I`.\r\n///\r\n/// If the inner [Task] is not ready yet, the factory will be called with `None`.\r\n/// Once the inner [Task] is ready, the factory will be called with `Some(I)`.\r\n///\r\n/// This is similar to the [FutureBuilder](https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html) from Flutter.\r\npub struct Fetcher<I: Send + 'static, O> {\r\n    task: Option<Box<dyn Task<I>>>,\r\n    factory: Box<dyn Fn(Option<I>) -> O>,\r\n    value: Option<O>,\r\n}\r\n\r\nimpl<I: Send + 'static, O> Fetcher<I, O> {\r\n    /// Create a new task fetcher with the given task and factory function.\r\n    #[inline(always)]\r\n    pub const fn new(\r\n        task: Box<dyn Task<I>>,\r\n        factory: Box<dyn Fn(Option<I>) -> O + 'static>,\r\n    ) -> Self {\r\n        Self {\r\n            task: Some(task),\r\n            factory,\r\n            value: None,\r\n        }\r\n    }\r\n\r\n    /// Spawn a future using the [TaskRunner](runner::TaskRunner)\r\n    /// and create a new [Fetcher] with the resulting task and the given factory function.\r\n    ///\r\n    /// If you want to spawn a blocking task, use [Fetcher::spawn_blocking] instead.\r\n    #[inline(always)]\r\n    pub fn spawn(\r\n        future: impl Future<Output = I> + Send + 'static,\r\n        factory: impl Fn(Option<I>) -> O + 'static,\r\n    ) -> Self {\r\n        let runner = runner();\r\n        let task = runner.spawn(future);\r\n\r\n        Self::new(task, Box::new(factory))\r\n    }\r\n\r\n    /// Spawn a blocking function using the [TaskRunner](runner::TaskRunner)\r\n    /// and create a new [Fetcher] with the resulting task and the given factory function.\r\n    ///\r\n    /// If your task is non-blocking (a simple future), use [Fetcher::spawn] instead.\r\n    #[inline(always)]\r\n    #[cfg(native)]\r\n    pub fn spawn_blocking(\r\n        func: impl Fn() -> I + Send + 'static,\r\n        factory: impl Fn(Option<I>) -> O + 'static,\r\n    ) -> Self {\r\n        let runner = runner();\r\n        let task = runner.spawn_blocking(func);\r\n\r\n        Self::new(task, Box::new(factory))\r\n    }\r\n\r\n    /// Returns a mutable reference to the possible output value.\r\n    ///\r\n    /// This is mostly used internally and will return the cached output value.\r\n    #[inline(always)]\r\n    pub const fn value_mut(&mut self) -> Option<&mut O> {\r\n        self.value.as_mut()\r\n    }\r\n\r\n    /// Returns a reference to the possible output value.\r\n    ///\r\n    /// This is mostly used internally and will return the cached output value.\r\n    #[inline(always)]\r\n    pub const fn value_ref(&self) -> Option<&O> {\r\n        self.value.as_ref()\r\n    }\r\n\r\n    /// Returns whether the inner task is ready.\r\n    ///\r\n    /// **NOTE:** This will only return `true`, if the inner task has finished,\r\n    /// but the value has not been consumed yet.\r\n    #[inline(always)]\r\n    pub fn is_ready(&self) -> bool {\r\n        self.task.as_ref().map(|t| t.is_ready()).unwrap_or(false)\r\n    }\r\n\r\n    /// Returns whether the inner task has finished and the value has been computed.\r\n    #[inline(always)]\r\n    pub const fn is_fetched(&self) -> bool {\r\n        self.task.is_none() && self.value.is_some()\r\n    }\r\n\r\n    /// Computes the output value from the inner task.\r\n    ///\r\n    /// If the inner task is not ready, the factory function will be called with `None`.\r\n    /// Otherwise, it will be called with `Some(I)`.\r\n    #[inline(always)]\r\n    pub fn compute(&mut self) {\r\n        if self.is_ready() {\r\n            let mut task = self.task.take().unwrap();\r\n            let value = task.take().unwrap();\r\n\r\n            self.value = Some((self.factory)(Some(value)));\r\n        } else {\r\n            self.value = Some((self.factory)(None));\r\n        }\r\n    }\r\n\r\n    /// Fetches the output value and returns a mutable reference.\r\n    ///\r\n    /// This will only actually compute the value,\r\n    /// if the task is not fully finished yet,\r\n    /// so it's safe to call, even if the task is already done.\r\n    #[inline(always)]\r\n    pub fn fetch(&mut self) -> &mut O {\r\n        if !self.is_fetched() {\r\n            self.compute();\r\n        }\r\n\r\n        self.value_mut().unwrap()\r\n    }\r\n}\r\n\r\n#[cfg(all(test, feature = \"test\"))]\r\nmod tests {\r\n    use crate::tasks::fetcher::Fetcher;\r\n    use std::time::Duration;\r\n\r\n    #[test]\r\n    fn test_fetcher_spawn() {\r\n        init();\r\n\r\n        let mut fetcher = Fetcher::spawn(\r\n            async { tokio::time::sleep(Duration::from_millis(10)).await },\r\n            |_| 1,\r\n        );\r\n\r\n        std::thread::sleep(Duration::from_millis(20));\r\n\r\n        assert_eq!(fetcher.fetch(), &1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_fetcher_spawn_blocking() {\r\n        init();\r\n\r\n        let mut fetcher =\r\n            Fetcher::spawn_blocking(|| std::thread::sleep(Duration::from_millis(10)), |_| 1);\r\n\r\n        std::thread::sleep(Duration::from_millis(20));\r\n\r\n        assert_eq!(fetcher.fetch(), &1);\r\n    }\r\n\r\n    fn init() {\r\n        crate::tasks::try_init(crate::tasks::TaskRunner::Tokio(\r\n            crate::tasks::runner::tokio::TaskRunner::new(\r\n                false, None, None, None, None, None, None, None,\r\n            ),\r\n        ));\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":43,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":61,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":69,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":86,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":91,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":92,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":100,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":101,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":102,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":103,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":105,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":122,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":157,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":158,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":159,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":160,"address":[],"length":0,"stats":{"Line":864691128455135232}}],"covered":29,"coverable":32},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","tasks","mod.rs"],"content":"use crate::tasks::runner::TaskRunner;\r\nuse crate::tasks::task::{LocalTask, Task};\r\nuse std::sync::OnceLock;\r\n\r\n/// Contains the [TaskRunner] and related structures.\r\npub mod runner;\r\n\r\n/// Contains the [Task] and [task::LocalTask] traits.\r\npub mod task;\r\n\r\n/// Contains a dummy implementation of a waker. Used in [Task::take].\r\npub mod waker;\r\n\r\n/// Contains the [fetcher::Fetcher] structure.\r\npub mod fetcher;\r\n\r\n/// The global task runner.\r\nstatic RUNNER: OnceLock<TaskRunner> = OnceLock::new();\r\n\r\n/// Tries to initialize the task runner, if it isn't yet.\r\n#[inline(always)]\r\npub fn try_init(runner: TaskRunner) {\r\n    RUNNER.get_or_init(move || runner);\r\n}\r\n\r\n/// Initializes the global task runner.\r\n///\r\n/// Panics if the task runner is already initialized.\r\n#[inline(always)]\r\npub fn init(runner: TaskRunner) {\r\n    RUNNER.set(runner).expect(\"Task runner already initialized\");\r\n}\r\n\r\n/// Try to get the global task runner.\r\n/// Returns [None] if the task runner is not initialized.\r\n#[inline(always)]\r\npub fn try_runner<'a>() -> Option<&'a TaskRunner> {\r\n    RUNNER.get()\r\n}\r\n\r\n/// Get the global task runner.\r\n///\r\n/// Panics if the task runner is not initialized.\r\n#[inline(always)]\r\npub fn runner<'a>() -> &'a TaskRunner {\r\n    RUNNER.get().expect(\"Task runner not initialized\")\r\n}\r\n\r\n/// Spawns a task on the global task runner.\r\n///\r\n/// If this actually spawns a task on a background task or just spawns a local task,\r\n/// depends on the [TaskRunner] type that is in use.\r\n#[inline(always)]\r\npub fn spawn<Fut>(future: Fut) -> Box<dyn Task<Fut::Output>>\r\nwhere\r\n    Fut: Future + Send + 'static,\r\n    Fut::Output: Send + 'static,\r\n{\r\n    runner().spawn(future)\r\n}\r\n\r\n/// Spawns a local task on the global task runner.\r\n///\r\n/// The local task will run on the current thread\r\n/// and will be executed by the application event loop.\r\n#[inline(always)]\r\npub fn spawn_local<Fut>(future: Fut) -> Box<dyn LocalTask<Fut::Output>>\r\nwhere\r\n    Fut: Future + 'static,\r\n    Fut::Output: 'static,\r\n{\r\n    runner().spawn_local(future)\r\n}\r\n\r\n/// Spawns a blocking task on the global task runner.\r\n///\r\n/// This will always spawn a task in a background thread,\r\n/// as local spawning would block the thread.\r\n///\r\n/// Only available on native platforms.\r\n#[inline(always)]\r\n#[cfg(native)]\r\npub fn spawn_blocking<R, F>(func: F) -> Box<dyn Task<R>>\r\nwhere\r\n    R: Send + 'static,\r\n    F: FnOnce() -> R + Send + 'static,\r\n{\r\n    runner().spawn_blocking(func)\r\n}\r\n\r\n/// Blocks the current thread on the global task runner until the future is ready.\r\n///\r\n/// Only available on native platforms.\r\n#[inline(always)]\r\n#[cfg(native)]\r\npub fn block_on<Fut>(future: Fut) -> Fut::Output\r\nwhere\r\n    Fut: Future,\r\n{\r\n    runner().block_on(future)\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":23,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":16},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","tasks","runner","mod.rs"],"content":"use crate::tasks::task::{LocalTask, Task};\r\nuse std::fmt::Debug;\r\n\r\n/// Contains implementations of [Task], [LocalTask] and [TaskRunnerImpl] using [tokio].\r\n#[cfg(all(native, feature = \"tokio-runner\"))]\r\npub mod tokio;\r\n\r\n/// A task runner that can be used to spawn tasks.\r\n///\r\n/// The fields will only be available, if the corresponding feature is enabled.\r\n#[derive(Debug)]\r\npub enum TaskRunner {\r\n    /// A task runner that uses the [tokio] runtime.\r\n    #[cfg(feature = \"tokio-runner\")]\r\n    Tokio(tokio::TaskRunner),\r\n    /// A dummy task runner that will panic on any method call.\r\n    /// Useful if you want to disable the task runner feature,\r\n    /// but still want the build script to work (e.g. for libraries).\r\n    #[cfg(feature = \"dummy-runner\")]\r\n    Dummy,\r\n}\r\n\r\nimpl TaskRunner {\r\n    /// Spawns a task, possibly in the background.\r\n    ///\r\n    /// Returns a task handle to the future.\r\n    ///\r\n    /// Panics, when no valid task runner is enabled.\r\n    #[inline(always)]\r\n    #[tracing::instrument(skip_all)]\r\n    pub fn spawn<Fut>(&self, _future: Fut) -> Box<dyn Task<Fut::Output>>\r\n    where\r\n        Fut: Future + Send + 'static,\r\n        Fut::Output: Send + 'static,\r\n    {\r\n        match self {\r\n            #[cfg(feature = \"tokio-runner\")]\r\n            TaskRunner::Tokio(rt) => Box::new(rt.spawn(_future)),\r\n\r\n            _ => {\r\n                panic!(\r\n                    \"No valid task runner feature selected. Please select a `-runner` feature (e.g. `tokio-runner`).\"\r\n                );\r\n\r\n                // Required for code to compile\r\n                #[allow(unreachable_code)]\r\n                Box::new(crate::tasks::task::NeverTask::new())\r\n            },\r\n        }\r\n    }\r\n\r\n    /// Spawns a local task, that will run on the current thread.\r\n    ///\r\n    /// Returns a task handle to the future.\r\n    ///\r\n    /// Panics, when no valid task runner is enabled.\r\n    #[inline(always)]\r\n    #[tracing::instrument(skip_all)]\r\n    pub fn spawn_local<Fut>(&self, _future: Fut) -> Box<dyn LocalTask<Fut::Output>>\r\n    where\r\n        Fut: Future + 'static,\r\n        Fut::Output: 'static,\r\n    {\r\n        match self {\r\n            #[cfg(feature = \"tokio-runner\")]\r\n            TaskRunner::Tokio(rt) => Box::new(rt.spawn_local(_future)),\r\n\r\n            _ => {\r\n                panic!(\r\n                    \"No valid task runner feature selected. Please select a `-runner` feature (e.g. `tokio-runner`).\"\r\n                );\r\n\r\n                // Required for code to compile\r\n                #[allow(unreachable_code)]\r\n                Box::new(crate::tasks::task::LocalNeverTask::new())\r\n            },\r\n        }\r\n    }\r\n\r\n    /// Spawns a blocking task in the background.\r\n    ///\r\n    /// Returns a task handle to the operation.\r\n    ///\r\n    /// Panics, when no valid task runner is enabled.\r\n    #[inline(always)]\r\n    #[cfg(native)]\r\n    #[tracing::instrument(skip_all)]\r\n    pub fn spawn_blocking<R, F>(&self, _func: F) -> Box<dyn Task<R>>\r\n    where\r\n        R: Send + 'static,\r\n        F: FnOnce() -> R + Send + 'static,\r\n    {\r\n        match self {\r\n            #[cfg(feature = \"tokio-runner\")]\r\n            TaskRunner::Tokio(rt) => Box::new(rt.spawn_blocking(_func)),\r\n\r\n            _ => {\r\n                panic!(\r\n                    \"No valid task runner feature selected. Please select a `-runner` feature (e.g. `tokio-runner`).\"\r\n                );\r\n\r\n                // Required for code to compile\r\n                #[allow(unreachable_code)]\r\n                Box::new(crate::tasks::task::NeverTask::new())\r\n            },\r\n        }\r\n    }\r\n\r\n    /// Blocks on the given future, until it's completed.\r\n    ///\r\n    /// Panics, when no valid task runner is enabled.\r\n    #[inline(always)]\r\n    #[cfg(native)]\r\n    #[tracing::instrument(skip_all)]\r\n    pub fn block_on<Fut>(&self, _future: Fut) -> Fut::Output\r\n    where\r\n        Fut: Future,\r\n    {\r\n        match self {\r\n            #[cfg(feature = \"tokio-runner\")]\r\n            TaskRunner::Tokio(rt) => rt.block_on(_future),\r\n\r\n            _ => panic!(\r\n                \"No valid task runner feature selected. Please select a `-runner` feature (e.g. `tokio-runner`).\"\r\n            ),\r\n        }\r\n    }\r\n\r\n    /// Allows the task runner to perform work on the current thread for one tick.\r\n    ///\r\n    /// The task runner should return as soon as possible (after the first `await` point is reached),\r\n    /// to avoid blocks and freezes.\r\n    #[inline(always)]\r\n    #[tracing::instrument(skip_all)]\r\n    pub fn tick(&self) {\r\n        match self {\r\n            #[cfg(feature = \"tokio-runner\")]\r\n            TaskRunner::Tokio(rt) => rt.tick(),\r\n\r\n            _ => panic!(\r\n                \"No valid task runner feature selected. Please select a `-runner` feature (e.g. `tokio-runner`).\"\r\n            ),\r\n        }\r\n    }\r\n}\r\n\r\n/// A trait that provides a task runner implementation.\r\npub trait TaskRunnerImpl: Debug + 'static {\r\n    /// The task type, that this task runner implementation uses.\r\n    type Task<T: Send + 'static>: Task<T>;\r\n\r\n    /// The local task type, that this task runner implementation uses.\r\n    type LocalTask<T: 'static>: LocalTask<T>;\r\n\r\n    /// Spawns a task, possibly in the background.\r\n    ///\r\n    /// Returns a task handle to the future.\r\n    fn spawn<Fut>(&self, future: Fut) -> Self::Task<Fut::Output>\r\n    where\r\n        Fut: Future + Send + 'static,\r\n        Fut::Output: Send + 'static;\r\n\r\n    /// Spawns a local task, that will run on the current thread.\r\n    ///\r\n    /// The task will be executed by the application event loop via [TaskRunnerImpl::tick].\r\n    ///\r\n    /// Returns a task handle to the future.\r\n    fn spawn_local<Fut>(&self, future: Fut) -> Self::LocalTask<Fut::Output>\r\n    where\r\n        Fut: Future + 'static,\r\n        Fut::Output: 'static;\r\n\r\n    /// Spawns a blocking task in the background.\r\n    ///\r\n    /// Returns a task handle to the operation.\r\n    #[cfg(native)]\r\n    fn spawn_blocking<R, F>(&self, func: F) -> Self::Task<R>\r\n    where\r\n        R: Send + 'static,\r\n        F: FnOnce() -> R + Send + 'static;\r\n\r\n    /// Blocks on the given future, until it's completed.\r\n    #[cfg(native)]\r\n    fn block_on<Fut>(&self, future: Fut) -> Fut::Output\r\n    where\r\n        Fut: Future;\r\n\r\n    /// Allows the task runner to perform work on the current thread for one tick.\r\n    ///\r\n    /// The task runner should return as soon as possible (after the first `await` point is reached),\r\n    /// to avoid blocks and freezes.\r\n    fn tick(&self);\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":36,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":93,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":95,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":29},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","tasks","runner","tokio.rs"],"content":"use crate::tasks::runner::TaskRunnerImpl;\r\nuse crate::tasks::task::{LocalTask, Task};\r\nuse crate::tasks::waker::noop_waker;\r\nuse fragile::Fragile;\r\nuse std::future::ready;\r\nuse std::pin::Pin;\r\nuse std::task::{Context, Poll};\r\nuse std::time::Duration;\r\nuse tokio::runtime::{Builder, Runtime};\r\nuse tokio::task::{JoinHandle, LocalSet};\r\n\r\n/// A [TaskRunnerImpl] implementation that uses [tokio].\r\n#[derive(Debug)]\r\npub struct TaskRunner {\r\n    rt: Runtime,\r\n    local: Fragile<LocalSet>,\r\n}\r\n\r\nimpl TaskRunner {\r\n    /// Creates a new [TaskRunner] with the given configuration.\r\n    ///\r\n    /// Giving [None] to some config parameters will use the default value (that [tokio] uses).\r\n    #[inline(always)]\r\n    pub fn new(\r\n        io: bool,\r\n        stack_size: Option<usize>,\r\n        workers: Option<usize>,\r\n        max_io_events_per_tick: Option<usize>,\r\n        max_blocking_threads: Option<usize>,\r\n        event_interval: Option<u32>,\r\n        global_queue_interval: Option<u32>,\r\n        keep_alive: Option<Duration>,\r\n    ) -> Self {\r\n        let mut builder = Builder::new_multi_thread();\r\n\r\n        if io {\r\n            builder.enable_io();\r\n        }\r\n\r\n        if let Some(stack_size) = stack_size {\r\n            builder.thread_stack_size(stack_size);\r\n        }\r\n\r\n        if let Some(workers) = workers {\r\n            builder.worker_threads(workers);\r\n        }\r\n\r\n        if let Some(max_io_events_per_tick) = max_io_events_per_tick {\r\n            builder.max_io_events_per_tick(max_io_events_per_tick);\r\n        }\r\n\r\n        if let Some(max_blocking_threads) = max_blocking_threads {\r\n            builder.max_blocking_threads(max_blocking_threads);\r\n        }\r\n\r\n        if let Some(event_interval) = event_interval {\r\n            builder.event_interval(event_interval);\r\n        }\r\n\r\n        if let Some(global_queue_interval) = global_queue_interval {\r\n            builder.global_queue_interval(global_queue_interval);\r\n        }\r\n\r\n        if let Some(keep_alive) = keep_alive {\r\n            builder.thread_keep_alive(keep_alive);\r\n        }\r\n\r\n        Self {\r\n            rt: builder\r\n                .enable_time()\r\n                .build()\r\n                .expect(\"Failed to build tokio runtime\"),\r\n            local: Fragile::new(LocalSet::new()),\r\n        }\r\n    }\r\n}\r\n\r\nimpl TaskRunnerImpl for TaskRunner {\r\n    type Task<T: Send + 'static> = TokioTask<T>;\r\n    type LocalTask<T: 'static> = LocalTokioTask<T>;\r\n\r\n    #[inline(always)]\r\n    fn spawn<Fut>(&self, future: Fut) -> Self::Task<Fut::Output>\r\n    where\r\n        Fut: Future + Send + 'static,\r\n        Fut::Output: Send + 'static,\r\n    {\r\n        TokioTask(self.rt.spawn(future))\r\n    }\r\n\r\n    fn spawn_local<Fut>(&self, future: Fut) -> Self::LocalTask<Fut::Output>\r\n    where\r\n        Fut: Future + 'static,\r\n        Fut::Output: 'static,\r\n    {\r\n        LocalTokioTask(\r\n            self.local\r\n                .try_get()\r\n                .expect(\"`spawn_local` must be called from the main thread\")\r\n                .spawn_local(future),\r\n        )\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn spawn_blocking<R, F>(&self, func: F) -> Self::Task<R>\r\n    where\r\n        R: Send + 'static,\r\n        F: FnOnce() -> R + Send + 'static,\r\n    {\r\n        TokioTask(self.rt.spawn_blocking(func))\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn block_on<Fut>(&self, future: Fut) -> Fut::Output\r\n    where\r\n        Fut: Future,\r\n    {\r\n        self.rt.block_on(future)\r\n    }\r\n\r\n    fn tick(&self) {\r\n        self.block_on(async {\r\n            self.local\r\n                .try_get()\r\n                .expect(\"`tick` must be called from the main thread\")\r\n                .run_until(async { ready(()).await })\r\n                .await;\r\n        });\r\n    }\r\n}\r\n\r\n/// A [Task] implementation that uses [tokio].\r\npub struct TokioTask<T: Send + 'static>(JoinHandle<T>);\r\n\r\nimpl<T: Send + 'static> Task<T> for TokioTask<T> {\r\n    #[inline(always)]\r\n    fn is_ready(&self) -> bool {\r\n        self.0.is_finished()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn take(&mut self) -> Option<T> {\r\n        let pinned = Pin::new(&mut self.0);\r\n        let waker = noop_waker();\r\n        let mut ctx = Context::from_waker(&waker);\r\n\r\n        match pinned.poll(&mut ctx) {\r\n            Poll::Ready(value) => Some(value.expect(\"Failed to poll tokio task\")),\r\n            Poll::Pending => None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T: Send + 'static> Future for TokioTask<T> {\r\n    type Output = T;\r\n\r\n    #[inline(always)]\r\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<T> {\r\n        let pinned = Pin::new(&mut self.0);\r\n\r\n        match pinned.poll(cx) {\r\n            Poll::Ready(res) => Poll::Ready(res.expect(\"Failed to join tokio task\")),\r\n            Poll::Pending => Poll::Pending,\r\n        }\r\n    }\r\n}\r\n\r\n/// A [LocalTask] implementation that uses [tokio].\r\npub struct LocalTokioTask<T: 'static>(JoinHandle<T>);\r\n\r\nimpl<T: 'static> LocalTask<T> for LocalTokioTask<T> {\r\n    #[inline(always)]\r\n    fn is_ready(&self) -> bool {\r\n        self.0.is_finished()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn take(&mut self) -> Option<T> {\r\n        let pinned = Pin::new(&mut self.0);\r\n        let waker = noop_waker();\r\n        let mut ctx = Context::from_waker(&waker);\r\n\r\n        match pinned.poll(&mut ctx) {\r\n            Poll::Ready(value) => Some(value.expect(\"Failed to poll tokio task\")),\r\n            Poll::Pending => None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Future for LocalTokioTask<T> {\r\n    type Output = T;\r\n\r\n    #[inline(always)]\r\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<T> {\r\n        let pinned = Pin::new(&mut self.0);\r\n\r\n        match pinned.poll(cx) {\r\n            Poll::Ready(res) => Poll::Ready(res.expect(\"Failed to join tokio task\")),\r\n            Poll::Pending => Poll::Pending,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":73,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":138,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":142,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":143,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":144,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":145,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":147,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":148,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}}],"covered":24,"coverable":66},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","tasks","task.rs"],"content":"use std::pin::Pin;\r\nuse std::task::{Context, Poll};\r\n\r\n/// A task that **can** be spawned on a background thread.\r\n///\r\n/// The inner value requires to be [Send] and `static`.\r\npub trait Task<T: Send + 'static>: Future<Output = T> + Send + 'static {\r\n    /// Returns if the task is finished or still pending.\r\n    fn is_ready(&self) -> bool;\r\n\r\n    /// Tries to take the inner value if the task is finished.\r\n    ///\r\n    /// Returns [None] if the task is still pending.\r\n    ///\r\n    /// This should only be called if you are sure the task is ready (check via [Task::is_ready]).\r\n    /// Furthermore, calling this multiple times when the task is finished will probably raise a panic,\r\n    /// so make sure to only call this once, if the task is finished.\r\n    fn take(&mut self) -> Option<T>;\r\n}\r\n\r\n/// A task that is executed on the local thread.\r\n///\r\n/// Unlike [Task], the inner type does not need to be [Send].\r\npub trait LocalTask<T>: Future<Output = T> + 'static {\r\n    /// Returns if the task is finished or still pending.\r\n    fn is_ready(&self) -> bool;\r\n\r\n    /// Tries to take the inner value if the task is finished.\r\n    ///\r\n    /// Returns [None] if the task is still pending.\r\n    ///\r\n    /// This should only be called if you are sure the task is ready (check via [Task::is_ready]).\r\n    /// Furthermore, calling this multiple times when the task is finished will probably raise a panic,\r\n    /// so make sure to only call this once, if the task is finished.\r\n    fn take(&mut self) -> Option<T>;\r\n}\r\n\r\n/// A task that never completes.\r\n///\r\n/// This is the [Send]-safe variant of [LocalNeverTask].\r\n#[derive(Debug)]\r\npub struct NeverTask<T: Send + 'static>(std::marker::PhantomData<T>);\r\n\r\nimpl<T: Send + 'static> NeverTask<T> {\r\n    /// Creates a new [NeverTask].\r\n    #[inline(always)]\r\n    pub const fn new() -> Self {\r\n        Self(std::marker::PhantomData)\r\n    }\r\n}\r\n\r\nimpl<T: Send + 'static> Future for NeverTask<T> {\r\n    type Output = T;\r\n\r\n    #[inline(always)]\r\n    fn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\r\n        Poll::Pending\r\n    }\r\n}\r\n\r\nimpl<T: Send + 'static> Task<T> for NeverTask<T> {\r\n    #[inline(always)]\r\n    fn is_ready(&self) -> bool {\r\n        false\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn take(&mut self) -> Option<T> {\r\n        None\r\n    }\r\n}\r\n\r\nimpl<T: Send + 'static> Default for NeverTask<T> {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self::new()\r\n    }\r\n}\r\n\r\n/// A task that never completes.\r\n///\r\n/// This is the non-[Send]-safe variant of [NeverTask].\r\n#[derive(Debug, Default)]\r\npub struct LocalNeverTask<T: 'static>(std::marker::PhantomData<T>);\r\n\r\nimpl<T: 'static> LocalNeverTask<T> {\r\n    /// Create a new [LocalNeverTask].\r\n    #[inline(always)]\r\n    pub const fn new() -> Self {\r\n        Self(std::marker::PhantomData)\r\n    }\r\n}\r\n\r\nimpl<T: 'static> Future for LocalNeverTask<T> {\r\n    type Output = T;\r\n\r\n    #[inline(always)]\r\n    fn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\r\n        Poll::Pending\r\n    }\r\n}\r\n\r\nimpl<T: 'static> LocalTask<T> for LocalNeverTask<T> {\r\n    #[inline(always)]\r\n    fn is_ready(&self) -> bool {\r\n        false\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn take(&mut self) -> Option<T> {\r\n        None\r\n    }\r\n}\r\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","tasks","waker.rs"],"content":"use std::task::{RawWaker, RawWakerVTable, Waker};\r\n\r\n/// Creates a no-op waker.\r\n///\r\n/// Should only be used in certain cases.\r\n///\r\n/// Mostly used in [crate::tasks::task::Task::take].\r\n#[inline(always)]\r\npub const fn noop_waker() -> Waker {\r\n    unsafe { Waker::from_raw(noop_raw_waker()) }\r\n}\r\n\r\n/// Create a no-op raw waker.\r\n#[inline(always)]\r\nconst fn noop_raw_waker() -> RawWaker {\r\n    RawWaker::new(\r\n        std::ptr::null(),\r\n        &RawWakerVTable::new(clone, wake, wake_by_ref, drop),\r\n    )\r\n}\r\n\r\n/// No-op clone.\r\n#[inline(always)]\r\nconst fn clone(_: *const ()) -> RawWaker {\r\n    noop_raw_waker()\r\n}\r\n\r\n/// No-op wake.\r\n#[inline(always)]\r\nconst fn wake(_: *const ()) {}\r\n\r\n/// No-op wake-by-ref.\r\n#[inline(always)]\r\nconst fn wake_by_ref(_: *const ()) {}\r\n\r\n/// No-op drop.\r\n#[inline(always)]\r\nconst fn drop(_: *const ()) {}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":10,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":15,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":18,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":6,"coverable":10},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","vgi","dummy.rs"],"content":"use crate::vgi::kurbo::{\r\n    Affine, Circle, CircleSegment, CubicBez, Ellipse, QuadBez, Rect, RoundedRect, Stroke, Triangle,\r\n};\r\nuse crate::vgi::{FontData, Scene, VectorGraphicsInterface};\r\nuse nalgebra::Vector2;\r\nuse peniko::{Brush, Color, ImageBrush};\r\nuse std::any::Any;\r\nuse std::convert::Infallible;\r\nuse std::fmt::Debug;\r\nuse std::sync::Arc;\r\nuse winit::event_loop::ActiveEventLoop;\r\nuse winit::window::Window;\r\n\r\n/// A dummy graphics backend that does nothing.\r\n///\r\n/// Useful for testing.\r\n#[derive(Debug)]\r\npub struct DummyGraphics;\r\n\r\nimpl VectorGraphicsInterface for DummyGraphics {\r\n    type Error = Infallible;\r\n    type Scene = DummyScene;\r\n    type Config = ();\r\n\r\n    fn new(_: Self::Config) -> Result<Self, Self::Error>\r\n    where\r\n        Self: Sized,\r\n    {\r\n        Ok(Self)\r\n    }\r\n\r\n    fn init(\r\n        &mut self,\r\n        _window: Arc<Window>,\r\n        _event_loop: &ActiveEventLoop,\r\n    ) -> Result<(), Self::Error> {\r\n        Ok(())\r\n    }\r\n\r\n    fn render(\r\n        &mut self,\r\n        _window: Arc<Window>,\r\n        _event_loop: &ActiveEventLoop,\r\n        _scene: &Self::Scene,\r\n        _bg_color: Color,\r\n    ) -> Result<(), Self::Error> {\r\n        Ok(())\r\n    }\r\n\r\n    fn resize(\r\n        &mut self,\r\n        _window: Arc<Window>,\r\n        _event_loop: &ActiveEventLoop,\r\n        _size: Vector2<u32>,\r\n    ) -> Result<(), Self::Error> {\r\n        Ok(())\r\n    }\r\n\r\n    fn uninit(\r\n        &mut self,\r\n        _window: Arc<Window>,\r\n        _event_loop: &ActiveEventLoop,\r\n    ) -> Result<(), Self::Error> {\r\n        Ok(())\r\n    }\r\n\r\n    fn destroy(\r\n        &mut self,\r\n        _window: Arc<Window>,\r\n        _event_loop: &ActiveEventLoop,\r\n    ) -> Result<(), Self::Error> {\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// A dummy scene that does nothing.\r\n///\r\n/// Useful for testing.\r\npub struct DummyScene;\r\n\r\nimpl Scene for DummyScene {\r\n    fn new() -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        unimplemented!(\"This is a dummy scene\")\r\n    }\r\n\r\n    fn as_any(&self) -> &dyn Any {\r\n        self\r\n    }\r\n\r\n    fn as_any_mut(&mut self) -> &mut dyn Any {\r\n        self\r\n    }\r\n\r\n    fn dyn_clone(&self) -> Box<dyn Scene> {\r\n        Box::new(DummyScene)\r\n    }\r\n\r\n    fn reset(&mut self) {}\r\n\r\n    fn append(&mut self, _other: &dyn Scene, _transform: Option<Affine>) {}\r\n\r\n    fn draw_rect(\r\n        &mut self,\r\n        _brush: &Brush,\r\n        _transform: Option<Affine>,\r\n        _stroke: Option<&Stroke>,\r\n        _rect: &Rect,\r\n    ) {\r\n    }\r\n\r\n    fn draw_rounded_rect(\r\n        &mut self,\r\n        _brush: &Brush,\r\n        _transform: Option<Affine>,\r\n        _stroke: Option<&Stroke>,\r\n        _rect: &RoundedRect,\r\n    ) {\r\n    }\r\n\r\n    fn draw_circle(\r\n        &mut self,\r\n        _brush: &Brush,\r\n        _transform: Option<Affine>,\r\n        _stroke: Option<&Stroke>,\r\n        _circle: &Circle,\r\n    ) {\r\n    }\r\n\r\n    fn draw_circle_segment(\r\n        &mut self,\r\n        _brush: &Brush,\r\n        _transform: Option<Affine>,\r\n        _stroke: Option<&Stroke>,\r\n        _circle_segment: &CircleSegment,\r\n    ) {\r\n    }\r\n\r\n    fn draw_ellipse(\r\n        &mut self,\r\n        _brush: &Brush,\r\n        _transform: Option<Affine>,\r\n        _stroke: Option<&Stroke>,\r\n        _ellipse: &Ellipse,\r\n    ) {\r\n    }\r\n\r\n    fn draw_cubic_bezier(\r\n        &mut self,\r\n        _brush: &Brush,\r\n        _transform: Option<Affine>,\r\n        _stroke: Option<&Stroke>,\r\n        _cubic_bez: &CubicBez,\r\n    ) {\r\n    }\r\n\r\n    fn draw_quadratic_bezier(\r\n        &mut self,\r\n        _brush: &Brush,\r\n        _transform: Option<Affine>,\r\n        _stroke: Option<&Stroke>,\r\n        _quad_bez: &QuadBez,\r\n    ) {\r\n    }\r\n\r\n    fn draw_triangle(\r\n        &mut self,\r\n        _brush: &Brush,\r\n        _transform: Option<Affine>,\r\n        _stroke: Option<&Stroke>,\r\n        _triangle: &Triangle,\r\n    ) {\r\n    }\r\n\r\n    fn draw_image(\r\n        &mut self,\r\n        _img: &ImageBrush,\r\n        _transform: Option<Affine>,\r\n        _position: Vector2<f32>,\r\n    ) {\r\n    }\r\n\r\n    fn draw_text(\r\n        &mut self,\r\n        _brush: &Brush,\r\n        _transform: Option<Affine>,\r\n        _position: Vector2<f32>,\r\n        _text: &str,\r\n        _hinting: bool,\r\n        _font: &FontData,\r\n        _size: f32,\r\n        _line_gap: f32,\r\n        _max_width: f32,\r\n    ) {\r\n    }\r\n\r\n    #[cfg(feature = \"svg\")]\r\n    fn draw_svg(&mut self, _svg: &usvg::Tree, _transform: Option<Affine>) {}\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","vgi","mod.rs"],"content":"use nalgebra::Vector2;\r\nuse std::any::Any;\r\nuse std::error::Error;\r\nuse std::fmt::Debug;\r\nuse std::sync::Arc;\r\nuse winit::event_loop::ActiveEventLoop;\r\nuse winit::window::Window;\r\n\r\nuse crate::vgi::kurbo::{\r\n    Affine, Circle, CircleSegment, CubicBez, Ellipse, QuadBez, Rect, RoundedRect, Stroke, Triangle,\r\n};\r\npub use peniko::*;\r\n\r\n#[cfg(feature = \"svg\")]\r\npub use usvg as svg;\r\n\r\n/// Contains the [vello::VectorGraphicsInterface] which uses [vello] as the backend.\r\n///\r\n/// This is the recommended graphics backend.\r\n///\r\n/// Requires the `vello-vg` feature (enabled by default).\r\n#[cfg(feature = \"vello-vg\")]\r\npub mod vello;\r\n\r\n/// Contains the [dummy::DummyGraphics] & [dummy::DummyGraphics] structs.\r\n///\r\n/// Useful for testing.\r\npub mod dummy;\r\n\r\n/// The default graphics backend for maycoon.\r\n///\r\n/// See [vello::VectorGraphicsInterface] for more.\r\n///\r\n/// Requires the `vello-vg` feature (enabled by default).\r\n#[cfg(feature = \"vello-vg\")]\r\npub type DefaultGraphics = vello::VectorGraphicsInterface;\r\n\r\n/// A trait describing ways to render vector graphics.\r\n///\r\n/// This is a universal interface for 2D vector graphics rendering.\r\npub trait VectorGraphicsInterface: Debug + 'static {\r\n    /// The error used by most graphics operations.\r\n    type Error: Error;\r\n    /// A direct interface for drawing vector graphics using this interface.\r\n    type Scene: Scene;\r\n    /// A configuration struct for initializing the interface.\r\n    type Config: Debug + Default + Clone;\r\n\r\n    /// Creates a new vector graphics interface using the given configuration.\r\n    ///\r\n    /// Returns an [Err] if the interface could not be created.\r\n    fn new(config: Self::Config) -> Result<Self, Self::Error>\r\n    where\r\n        Self: Sized;\r\n\r\n    /// Initializes the interface.\r\n    ///\r\n    /// This will be called on [winit::event::Event::Resumed] to initialize the graphics interface.\r\n    ///\r\n    /// Returns an [Err] if the interface could not be initialized.\r\n    fn init(\r\n        &mut self,\r\n        window: Arc<Window>,\r\n        event_loop: &ActiveEventLoop,\r\n    ) -> Result<(), Self::Error>;\r\n\r\n    /// Renders the scene to the window.\r\n    ///\r\n    /// This method should render the scene on a window surface and **present** the surface too.\r\n    ///\r\n    /// Returns an [Err] if the scene could not be rendered.\r\n    fn render(\r\n        &mut self,\r\n        window: Arc<Window>,\r\n        event_loop: &ActiveEventLoop,\r\n        scene: &Self::Scene,\r\n        bg_color: Color,\r\n    ) -> Result<(), Self::Error>;\r\n\r\n    /// Resizes the window.\r\n    ///\r\n    /// This method should resize the window surface to the given size.\r\n    ///\r\n    /// **NOTE**: Do not resize the window itself. This is already done automatically.\r\n    ///\r\n    /// Returns an [Err] if the window could not be resized.\r\n    fn resize(\r\n        &mut self,\r\n        window: Arc<Window>,\r\n        event_loop: &ActiveEventLoop,\r\n        size: Vector2<u32>,\r\n    ) -> Result<(), Self::Error>;\r\n\r\n    /// Uninitializes the interface.\r\n    ///\r\n    /// This will be called on [winit::event::Event::Suspended] to uninitialize the graphics interface.\r\n    ///\r\n    /// Returns an [Err] if the interface could not be uninitialized.\r\n    fn uninit(\r\n        &mut self,\r\n        window: Arc<Window>,\r\n        event_loop: &ActiveEventLoop,\r\n    ) -> Result<(), Self::Error>;\r\n\r\n    /// Destroys the interface.\r\n    ///\r\n    /// This will be called on [winit::event::WindowEvent::Destroyed] to destroy the graphics interface.\r\n    ///\r\n    /// Returns an [Err] if the interface could not be destroyed.\r\n    fn destroy(\r\n        &mut self,\r\n        window: Arc<Window>,\r\n        event_loop: &ActiveEventLoop,\r\n    ) -> Result<(), Self::Error>;\r\n}\r\n\r\n/// An interface for drawing vector graphics onto a canvas.\r\n///\r\n/// Must be provided by the [VectorGraphicsInterface].\r\npub trait Scene: 'static {\r\n    /// Creates a new empty scene.\r\n    fn new() -> Self\r\n    where\r\n        Self: Sized;\r\n\r\n    /// Returns this [Scene] as an [Any] reference.\r\n    fn as_any(&self) -> &dyn Any;\r\n\r\n    /// Returns this [Scene] as a mutable [Any] reference.\r\n    fn as_any_mut(&mut self) -> &mut dyn Any;\r\n\r\n    /// Clones this [Scene] and returns it boxed.\r\n    ///\r\n    /// Used to keep object safety while allowing the scene to be cloned.\r\n    fn dyn_clone(&self) -> Box<dyn Scene>;\r\n\r\n    /// Resets the [Scene] to its initial state.\r\n    ///\r\n    /// This scene should be equal to [Scene::new] after this call.\r\n    fn reset(&mut self);\r\n\r\n    /// Appends the given [Scene] to this [Scene].\r\n    ///\r\n    /// Apply an optional transform to the scene.\r\n    fn append(&mut self, other: &dyn Scene, transform: Option<Affine>);\r\n\r\n    /// Draws a rectangle onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the rectangle.\r\n    ///\r\n    /// Optionally, strokes and does not fill the rectangle.\r\n    fn draw_rect(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        rect: &Rect,\r\n    );\r\n\r\n    /// Draws a rounded rectangle onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the rectangle.\r\n    ///\r\n    /// Optionally, strokes and does not fill the rectangle.\r\n    fn draw_rounded_rect(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        rect: &RoundedRect,\r\n    );\r\n\r\n    /// Draws a circle onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the circle.\r\n    ///\r\n    /// Optionally, strokes and does not fill the circle.\r\n    fn draw_circle(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        circle: &Circle,\r\n    );\r\n\r\n    /// Draws a circle segment onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the circle segment.\r\n    ///\r\n    /// Optionally, strokes and does not fill the circle segment.\r\n    fn draw_circle_segment(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        circle_segment: &CircleSegment,\r\n    );\r\n\r\n    /// Draws an ellipse onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the ellipse.\r\n    ///\r\n    /// Optionally, strokes and does not fill the ellipse.\r\n    fn draw_ellipse(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        ellipse: &Ellipse,\r\n    );\r\n\r\n    /// Draws a cubic bezier onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the cubic bezier.\r\n    ///\r\n    /// Optionally, strokes and does not fill the cubic bezier.\r\n    fn draw_cubic_bezier(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        cubic_bez: &CubicBez,\r\n    );\r\n\r\n    /// Draws a quadratic bezier onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the quadratic bezier.\r\n    ///\r\n    /// Optionally, strokes and does not fill the quadratic bezier.\r\n    fn draw_quadratic_bezier(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        quad_bez: &QuadBez,\r\n    );\r\n\r\n    /// Draws a triangle onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the triangle.\r\n    ///\r\n    /// Optionally, strokes and does not fill the triangle.\r\n    fn draw_triangle(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        triangle: &Triangle,\r\n    );\r\n\r\n    /// Draws an image onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the image (after the position is inserted).\r\n    fn draw_image(&mut self, img: &ImageBrush, transform: Option<Affine>, position: Vector2<f32>);\r\n\r\n    /// Draws text onto the [Scene] with the given brush.\r\n    ///\r\n    /// Apply an optional transform to the text (after the position is inserted).\r\n    ///\r\n    /// You can also specify hinting, size, and the line gap.\r\n    ///\r\n    /// Furthermore, you can choose if the text should be wrapped by passing `max_width`.\r\n    fn draw_text(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        position: Vector2<f32>,\r\n        text: &str,\r\n        hinting: bool,\r\n        font: &FontData,\r\n        size: f32,\r\n        line_gap: f32,\r\n        max_width: f32,\r\n    );\r\n\r\n    // TODO: add `Affine` transform arg as soon as vello_svg supports it\r\n    /// Draws an SVG onto the [Scene] with an optional transform.\r\n    ///\r\n    /// Only enabled if the [svg] feature is enabled.\r\n    #[cfg(feature = \"svg\")]\r\n    fn draw_svg(&mut self, svg: &usvg::Tree, transform: Option<Affine>);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","vgi","vello.rs"],"content":"use crate::vgi::FontData;\r\nuse crate::vgi::kurbo::Stroke;\r\nuse crate::{tasks, vgi};\r\nuse nalgebra::Vector2;\r\nuse peniko::kurbo::{CubicBez, Triangle};\r\nuse peniko::{Brush, Color, Fill, ImageBrush};\r\nuse skrifa::instance::Size;\r\nuse skrifa::setting::VariationSetting;\r\nuse skrifa::{FontRef, MetadataProvider};\r\nuse std::any::Any;\r\nuse std::fmt::Debug;\r\nuse std::num::NonZeroUsize;\r\nuse std::sync::Arc;\r\npub use vello::AaConfig as Antialiasing;\r\nuse vello::kurbo::{\r\n    Affine, Circle, CircleSegment, Ellipse, QuadBez, Rect, RoundedRect, Shape, Vec2,\r\n};\r\nuse vello::util::{DeviceHandle, RenderContext, RenderSurface};\r\nuse vello::{AaSupport, Error, Glyph, RenderParams, Renderer, RendererOptions};\r\npub use wgpu_types::PresentMode;\r\nuse wgpu_types::{CommandEncoderDescriptor, TextureViewDescriptor};\r\nuse winit::event_loop::ActiveEventLoop;\r\nuse winit::window::Window;\r\n\r\n/// A vector graphics interface using [vello] as the backend.\r\n///\r\n/// This is the recommended graphics backend.\r\n///\r\n/// Requires the `vello-vg` feature (enabled by default).\r\n///\r\n/// Uses [vello] and [wgpu](https://crates.io/crates/wgpu) to render vector graphics.\r\npub struct VectorGraphicsInterface {\r\n    config: VectorGraphicsConfig,\r\n    context: RenderContext,\r\n    renderer: Option<Renderer>,\r\n    surface: Option<RenderSurface<'static>>,\r\n    device: usize,\r\n}\r\n\r\nimpl vgi::VectorGraphicsInterface for VectorGraphicsInterface {\r\n    type Error = Error;\r\n    type Scene = Scene;\r\n    type Config = VectorGraphicsConfig;\r\n\r\n    #[inline(always)]\r\n    fn new(config: Self::Config) -> Result<Self, Self::Error>\r\n    where\r\n        Self: Sized,\r\n    {\r\n        Ok(Self {\r\n            config,\r\n            context: RenderContext::new(),\r\n            renderer: None,\r\n            surface: None,\r\n            device: 0,\r\n        })\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn init(&mut self, window: Arc<Window>, _: &ActiveEventLoop) -> Result<(), Self::Error> {\r\n        let size = window.inner_size();\r\n\r\n        self.surface = Some(tasks::block_on(self.context.create_surface(\r\n            window,\r\n            size.width,\r\n            size.height,\r\n            self.config.present_mode,\r\n        ))?);\r\n\r\n        self.device = (self.config.device_selector)(&self.context.devices);\r\n        let device = &self.context.devices[self.device];\r\n\r\n        self.renderer = Some(Renderer::new(\r\n            &device.device,\r\n            RendererOptions {\r\n                use_cpu: false,\r\n                antialiasing_support: match self.config.antialiasing {\r\n                    Antialiasing::Area => AaSupport::area_only(),\r\n                    Antialiasing::Msaa8 => AaSupport {\r\n                        area: false,\r\n                        msaa8: true,\r\n                        msaa16: false,\r\n                    },\r\n                    Antialiasing::Msaa16 => AaSupport {\r\n                        area: false,\r\n                        msaa8: false,\r\n                        msaa16: true,\r\n                    },\r\n                },\r\n                num_init_threads: Some(self.config.init_threads),\r\n                pipeline_cache: None,\r\n            },\r\n        )?);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn render(\r\n        &mut self,\r\n        window: Arc<Window>,\r\n        _: &ActiveEventLoop,\r\n        scene: &Self::Scene,\r\n        bg_color: Color,\r\n    ) -> Result<(), Self::Error> {\r\n        let renderer = self\r\n            .renderer\r\n            .as_mut()\r\n            .expect(\"Vector graphics not initialized yet\");\r\n        let surface = self\r\n            .surface\r\n            .as_ref()\r\n            .expect(\"Vector graphics not initialized yet\");\r\n        let device_handle = &self.context.devices[self.device];\r\n\r\n        renderer.render_to_texture(\r\n            &device_handle.device,\r\n            &device_handle.queue,\r\n            &scene.scene,\r\n            &surface.target_view,\r\n            &RenderParams {\r\n                base_color: bg_color,\r\n                width: window.inner_size().width,\r\n                height: window.inner_size().height,\r\n                antialiasing_method: self.config.antialiasing,\r\n            },\r\n        )?;\r\n\r\n        let surface_texture = surface\r\n            .surface\r\n            .get_current_texture()\r\n            .expect(\"Failed to get current surface texture\");\r\n\r\n        let mut encoder = device_handle\r\n            .device\r\n            .create_command_encoder(&CommandEncoderDescriptor {\r\n                label: Some(\"Surface Blit Encoder\"),\r\n            });\r\n\r\n        surface.blitter.copy(\r\n            &device_handle.device,\r\n            &mut encoder,\r\n            &surface.target_view,\r\n            &surface_texture\r\n                .texture\r\n                .create_view(&TextureViewDescriptor::default()),\r\n        );\r\n\r\n        device_handle.queue.submit([encoder.finish()]);\r\n\r\n        window.pre_present_notify();\r\n\r\n        surface_texture.present();\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn resize(\r\n        &mut self,\r\n        _: Arc<Window>,\r\n        _: &ActiveEventLoop,\r\n        size: Vector2<u32>,\r\n    ) -> Result<(), Self::Error> {\r\n        self.context.resize_surface(\r\n            self.surface\r\n                .as_mut()\r\n                .expect(\"Vector graphics not initialized yet\"),\r\n            size.x,\r\n            size.y,\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[cold]\r\n    fn uninit(&mut self, _: Arc<Window>, _: &ActiveEventLoop) -> Result<(), Self::Error> {\r\n        self.renderer = None;\r\n        self.surface = None;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[cold]\r\n    fn destroy(&mut self, _: Arc<Window>, _: &ActiveEventLoop) -> Result<(), Self::Error> {\r\n        for device in &self.context.devices {\r\n            device.device.destroy();\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl Debug for VectorGraphicsInterface {\r\n    #[inline(always)]\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        f.debug_struct(\"VectorGraphicsInterface\")\r\n            .field(\"config\", &self.config)\r\n            .field(\"context\", &\"<hidden>\")\r\n            .field(\"renderer\", &\"<hidden>\")\r\n            .field(\"surface\", &self.surface)\r\n            .field(\"device\", &self.device)\r\n            .finish()\r\n    }\r\n}\r\n\r\n/// A configuration struct for initializing the [VectorGraphicsInterface].\r\n///\r\n/// This struct is passed to [VectorGraphicsInterface::new].\r\n#[derive(Debug, Copy, Clone)]\r\npub struct VectorGraphicsConfig {\r\n    /// The present mode to use for the surface. Defaults to [PresentMode::AutoNoVsync].\r\n    pub present_mode: PresentMode,\r\n    /// A function to select a device. All devices that are given to this function are compatible.\r\n    ///\r\n    /// Default is to panic if the list is empty or select the first device.\r\n    pub device_selector: fn(&Vec<DeviceHandle>) -> usize,\r\n    /// Use the CPU for some rendering work.\r\n    ///\r\n    /// **NOTE**: This does not disable GPU-usage. Rasterization will still be done by the GPU:\r\n    pub use_cpu: bool,\r\n    /// The antialiasing configuration for the renderer. Defaults to [Antialiasing::Area].\r\n    pub antialiasing: Antialiasing,\r\n    /// The threads to use for renderer initialization. Defaults to 50% of [std::thread::available_parallelism] or 1 if it fails.\r\n    pub init_threads: NonZeroUsize,\r\n}\r\n\r\nimpl Default for VectorGraphicsConfig {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self {\r\n            present_mode: PresentMode::AutoNoVsync,\r\n            device_selector: |dev| {\r\n                if dev.is_empty() {\r\n                    panic!(\"No compatible devices found.\")\r\n                } else {\r\n                    0\r\n                }\r\n            },\r\n            use_cpu: false,\r\n            antialiasing: Antialiasing::Area,\r\n            init_threads: NonZeroUsize::new(\r\n                std::thread::available_parallelism()\r\n                    .map(|p| ((p.get() as f32 * 0.5).round() as usize).clamp(1, usize::MAX))\r\n                    .unwrap_or(1),\r\n            )\r\n            .unwrap(),\r\n        }\r\n    }\r\n}\r\n\r\n/// A scene to draw on. Uses [vello::Scene] under the hood.\r\n#[derive(Clone, Default)]\r\npub struct Scene {\r\n    scene: vello::Scene,\r\n}\r\n\r\nimpl Scene {\r\n    #[inline(always)]\r\n    fn draw(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        shape: &impl Shape,\r\n    ) {\r\n        let transform = transform.unwrap_or_default();\r\n\r\n        if let Some(stroke) = stroke {\r\n            self.scene.stroke(stroke, transform, brush, None, shape);\r\n        } else {\r\n            self.scene\r\n                .fill(Fill::NonZero, transform, brush, None, shape);\r\n        }\r\n    }\r\n}\r\n\r\nimpl vgi::Scene for Scene {\r\n    #[inline(always)]\r\n    fn new() -> Self {\r\n        Self {\r\n            scene: vello::Scene::new(),\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn as_any(&self) -> &dyn Any {\r\n        self\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn as_any_mut(&mut self) -> &mut dyn Any {\r\n        self\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn dyn_clone(&self) -> Box<dyn vgi::Scene> {\r\n        Box::new(self.clone())\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn reset(&mut self) {\r\n        self.scene.reset();\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn append(&mut self, other: &dyn vgi::Scene, transform: Option<Affine>) {\r\n        let any = other.as_any();\r\n        let scene = any.downcast_ref::<Scene>().unwrap();\r\n\r\n        self.scene.append(&scene.scene, transform)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn draw_rect(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        rect: &Rect,\r\n    ) {\r\n        self.draw(brush, transform, stroke, rect)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn draw_rounded_rect(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        rect: &RoundedRect,\r\n    ) {\r\n        self.draw(brush, transform, stroke, rect)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn draw_circle(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        circle: &Circle,\r\n    ) {\r\n        self.draw(brush, transform, stroke, circle)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn draw_circle_segment(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        circle_segment: &CircleSegment,\r\n    ) {\r\n        self.draw(brush, transform, stroke, circle_segment)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn draw_ellipse(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        ellipse: &Ellipse,\r\n    ) {\r\n        self.draw(brush, transform, stroke, ellipse)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn draw_cubic_bezier(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        cubic_bez: &CubicBez,\r\n    ) {\r\n        self.draw(brush, transform, stroke, cubic_bez)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn draw_quadratic_bezier(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        quad_bez: &QuadBez,\r\n    ) {\r\n        self.draw(brush, transform, stroke, quad_bez)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn draw_triangle(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        stroke: Option<&Stroke>,\r\n        triangle: &Triangle,\r\n    ) {\r\n        self.draw(brush, transform, stroke, triangle)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn draw_image(&mut self, img: &ImageBrush, transform: Option<Affine>, position: Vector2<f32>) {\r\n        let transform = transform\r\n            .unwrap_or_default()\r\n            .with_translation(Vec2::new(position.x as f64, position.y as f64));\r\n\r\n        self.scene.draw_image(img, transform);\r\n    }\r\n\r\n    fn draw_text(\r\n        &mut self,\r\n        brush: &Brush,\r\n        transform: Option<Affine>,\r\n        position: Vector2<f32>,\r\n        text: &str,\r\n        hinting: bool,\r\n        font: &FontData,\r\n        size: f32,\r\n        line_gap: f32,\r\n        max_width: f32,\r\n    ) {\r\n        let font_ref = FontRef::new(font.data.as_ref()).expect(\"Failed to load font ref\");\r\n\r\n        let location = font_ref.axes().location::<&[VariationSetting; 0]>(&[]);\r\n        let metrics = font_ref.metrics(Size::new(size), &location);\r\n        let glyph_metrics = font_ref.glyph_metrics(Size::new(size), &location);\r\n        let line_height = metrics.ascent + metrics.descent + metrics.leading;\r\n        let charmap = font_ref.charmap();\r\n        let max_pen_x = position.x + max_width;\r\n\r\n        let mut pen_x = position.x;\r\n        let mut pen_y = position.y + size;\r\n\r\n        // TODO: use char counting, but more performant than just `text.chars().count()`\r\n        let mut glyphs = Vec::with_capacity(text.len());\r\n\r\n        for word in text.split_inclusive(|c| [' ', '\\n'].contains(&c)) {\r\n            if word.contains('\\n') {\r\n                pen_y += line_height + line_gap;\r\n                pen_x = position.x;\r\n                continue;\r\n            }\r\n\r\n            let word_width: f32 = word\r\n                .chars()\r\n                .filter_map(|c| {\r\n                    let gid = charmap.map(c)?;\r\n                    glyph_metrics.advance_width(gid)\r\n                })\r\n                .sum();\r\n\r\n            if pen_x + word_width > max_pen_x {\r\n                pen_y += line_height + line_gap;\r\n                pen_x = position.x;\r\n            }\r\n\r\n            for c in word.chars() {\r\n                if c == ' ' {\r\n                    pen_x += glyph_metrics\r\n                        .advance_width(charmap.map(' ').unwrap_or_default())\r\n                        .unwrap_or_default();\r\n                    continue;\r\n                }\r\n\r\n                let gid = charmap.map(c).unwrap_or_default();\r\n                let advance = glyph_metrics.advance_width(gid).unwrap_or_default();\r\n\r\n                glyphs.push(Glyph {\r\n                    id: gid.to_u32(),\r\n                    x: pen_x,\r\n                    y: pen_y,\r\n                });\r\n\r\n                pen_x += advance;\r\n            }\r\n        }\r\n\r\n        self.scene\r\n            .draw_glyphs(font)\r\n            .font_size(size)\r\n            .transform(transform.unwrap_or_default())\r\n            .brush(brush)\r\n            .normalized_coords(bytemuck::cast_slice(location.coords()))\r\n            .hint(hinting)\r\n            .draw(&peniko::Style::Fill(Fill::NonZero), glyphs.into_iter());\r\n    }\r\n\r\n    #[inline(always)]\r\n    #[cfg(feature = \"svg\")]\r\n    fn draw_svg(&mut self, svg: &usvg::Tree, affine: Option<Affine>) {\r\n        let mut scene = vello::Scene::new();\r\n\r\n        vello_svg::append_tree(&mut scene, svg);\r\n\r\n        self.scene.append(&scene, affine);\r\n    }\r\n}\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":180},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-core","src","widget.rs"],"content":"use crate::app::context::AppContext;\r\nuse crate::app::info::AppInfo;\r\nuse crate::app::update::Update;\r\nuse crate::layout::{LayoutNode, LayoutStyle, StyleNode};\r\nuse crate::signal::MaybeSignal;\r\nuse crate::vgi::Scene;\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\n\r\n/// A boxed widget.\r\npub type BoxedWidget = Box<dyn Widget>;\r\n\r\n/// The base trait for all widgets.\r\npub trait Widget {\r\n    /// Render the widget to the canvas.\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        info: &AppInfo,\r\n        context: AppContext,\r\n    );\r\n\r\n    /// Return the layout style node for layout computation.\r\n    fn layout_style(&self) -> StyleNode;\r\n\r\n    /// Update the widget state with given info and layout. Returns if the app should be updated.\r\n    fn update(&mut self, layout: &LayoutNode, context: AppContext, info: &AppInfo) -> Update;\r\n\r\n    /// Return the widget id.\r\n    fn widget_id(&self) -> WidgetId;\r\n}\r\n\r\n/// An extension trait for widgets with a single child widget.\r\npub trait WidgetChildExt {\r\n    /// Sets the child widget of the widget.\r\n    fn set_child(&mut self, child: impl Widget + 'static);\r\n\r\n    /// Sets the child widget of the widget and returns self.\r\n    #[inline(always)]\r\n    fn with_child(mut self, child: impl Widget + 'static) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self.set_child(child);\r\n        self\r\n    }\r\n}\r\n\r\n/// An extension trait for widgets with multiple child widgets.\r\npub trait WidgetChildrenExt {\r\n    /// Sets the child widgets of the widget.\r\n    fn set_children(&mut self, children: Vec<BoxedWidget>);\r\n\r\n    /// Sets the child widgets of the widget and returns self.\r\n    #[inline(always)]\r\n    fn with_children(mut self, children: Vec<BoxedWidget>) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self.set_children(children);\r\n        self\r\n    }\r\n\r\n    /// Adds a child widget to the widget.\r\n    fn add_child(&mut self, child: impl Widget + 'static);\r\n\r\n    /// Adds a child widget to the widget and returns self.\r\n    #[inline(always)]\r\n    fn with_child(mut self, child: impl Widget + 'static) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self.add_child(child);\r\n        self\r\n    }\r\n}\r\n\r\n/// An extension trait for widgets with a layout style.\r\npub trait WidgetLayoutExt {\r\n    /// Sets the layout style of the widget.\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>);\r\n\r\n    /// Sets the layout style of the widget and returns self.\r\n    #[inline(always)]\r\n    fn with_layout_style(mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) -> Self\r\n    where\r\n        Self: Sized,\r\n    {\r\n        self.set_layout_style(layout_style);\r\n        self\r\n    }\r\n}\r\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-macros","src","assets.rs"],"content":"use proc_macro2::TokenStream;\r\nuse quote::quote;\r\nuse std::path::{Path, PathBuf};\r\nuse syn::{Expr, Lit};\r\n\r\n#[inline]\r\npub fn static_asset(input: TokenStream) -> TokenStream {\r\n    let input: Expr = syn::parse2(input).expect(\"failed to parse input\");\r\n\r\n    match input {\r\n        Expr::Lit(expr_lit) => match expr_lit.lit {\r\n            Lit::Str(lit) => {\r\n                let lit = lit.value();\r\n                let source = Path::new(&lit);\r\n\r\n                let file_name = source\r\n                    .file_name()\r\n                    .expect(\"Failed to get file name\")\r\n                    .to_str()\r\n                    .unwrap();\r\n\r\n                let data = if source.starts_with(\"http\") || source.starts_with(\"\") {\r\n                    std::fs::read_to_string(source).expect(\"Failed to read file\")\r\n                } else {\r\n                    get_or_create_asset(Path::new(\"icons\"), file_name, || {\r\n                        ureq::get(source.to_str().unwrap())\r\n                            .call()\r\n                            .expect(\"Failed to download file\")\r\n                            .into_body()\r\n                            .read_to_string()\r\n                            .expect(\"Failed to read file\")\r\n                    })\r\n                };\r\n\r\n                let data = data.as_str();\r\n\r\n                quote! {\r\n                    #data\r\n                }\r\n            },\r\n\r\n            _ => panic!(\"Expected string literal\"),\r\n        },\r\n\r\n        _ => panic!(\"Expected literal\"),\r\n    }\r\n}\r\n\r\npub fn temp_assets_folder() -> PathBuf {\r\n    let path = std::env::temp_dir().join(\"maycoon-compilation-assets\");\r\n\r\n    if !path.exists() {\r\n        std::fs::create_dir_all(&path).expect(\"failed to create static assets directory\");\r\n    }\r\n\r\n    path\r\n}\r\n\r\npub fn get_or_create_asset(path: &Path, name: &str, or_create: impl FnOnce() -> String) -> String {\r\n    let asset_folder = temp_assets_folder().join(path);\r\n\r\n    if !asset_folder.exists() {\r\n        std::fs::create_dir_all(&asset_folder).expect(\"failed to create static assets directory\");\r\n    }\r\n\r\n    let asset_path = asset_folder.join(name);\r\n\r\n    if asset_path.exists() {\r\n        std::fs::read_to_string(&asset_path).expect(\"failed to read static asset\")\r\n    } else {\r\n        let data = or_create();\r\n\r\n        std::fs::write(&asset_path, &data).expect(\"failed to write static asset\");\r\n\r\n        data\r\n    }\r\n}\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-macros","src","lib.rs"],"content":"#![warn(missing_docs)]\r\n\r\n//! Macros for Maycoon => See `maycoon` crate.\r\n//!\r\n//! Contains procedural macros.\r\n\r\nmod assets;\r\nmod svg_icon;\r\n\r\n/// Create a new `SvgIcon` from the given SVG source.\r\n///\r\n/// This is equivalent to `SvgIcon::new(static_asset!(url))` and works as a convenience macro.\r\n#[proc_macro]\r\npub fn svg_icon(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\r\n    proc_macro::TokenStream::from(svg_icon::svg_icon(proc_macro2::TokenStream::from(input)))\r\n}\r\n\r\n/// Creates a static asset from the given path/url and caches the file for faster compilation times.\r\n///\r\n/// This will either read a file path or download the file from the given URL using [ureq].\r\n/// After the data has been retrieved, it will be saved as a static asset file in a temporary directory (e.g. `%temp%` on windows).\r\n/// When re-executing this macro, the file can be re-loaded for faster compilation times.\r\n#[proc_macro]\r\npub fn static_asset(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\r\n    proc_macro::TokenStream::from(assets::static_asset(proc_macro2::TokenStream::from(input)))\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-macros","src","svg_icon.rs"],"content":"use crate::assets;\r\nuse proc_macro2::TokenStream;\r\nuse quote::quote;\r\nuse syn::LitStr;\r\n\r\n#[inline]\r\npub fn svg_icon(input: TokenStream) -> TokenStream {\r\n    let data = syn::parse2::<LitStr>(assets::static_asset(input))\r\n        .expect(\"failed to parse input\")\r\n        .value();\r\n\r\n    quote! {\r\n        maycoon::widgets::icon::svg::SvgIcon::new(#data).expect(\"failed to create SVG icon\")\r\n    }\r\n}\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-theme","src","globals.rs"],"content":"/// Global theme values for all widgets to use.\r\n///\r\n/// This may be used to invert the text color of widgets that are inside a container.\r\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq)]\r\npub struct Globals {\r\n    /// Invert text color.\r\n    pub invert_text_color: bool,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-theme","src","id.rs"],"content":"use std::fmt::{Debug, Display, Formatter};\r\n\r\n/// An identifier for a widget. This is not for instantiated widgets, but for the widget types in general.\r\n/// It contains a namespace, which should be the crate name and the id of the widget.\r\n///\r\n/// ```\r\n/// # use maycoon_theme::id::WidgetId;\r\n/// WidgetId::new(\"fancy_text_widget\", \"FancyText\");\r\n/// ```\r\n#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]\r\npub struct WidgetId {\r\n    namespace: &'static str,\r\n    id: &'static str,\r\n}\r\n\r\nimpl WidgetId {\r\n    /// Create a new widget id by a namespace and custom id.\r\n    /// The namespace should be the crate name and the id should be the widget type name.\r\n    ///\r\n    /// Example:\r\n    /// ```\r\n    /// # use maycoon_theme::id::WidgetId;\r\n    /// let id = WidgetId::new(\"my_crate\", \"MyWidget\");\r\n    /// ```\r\n    #[inline(always)]\r\n    pub const fn new(namespace: &'static str, id: &'static str) -> Self {\r\n        Self { namespace, id }\r\n    }\r\n\r\n    /// Returns the namespace of the widget id.\r\n    #[inline(always)]\r\n    pub const fn namespace(&self) -> &'static str {\r\n        self.namespace\r\n    }\r\n\r\n    /// Returns the actual widget id.\r\n    #[inline(always)]\r\n    pub const fn id(&self) -> &'static str {\r\n        self.id\r\n    }\r\n}\r\n\r\nimpl Display for WidgetId {\r\n    #[inline(always)]\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\r\n        // TODO: use const formatting/writing when const format is stable\r\n        write!(f, \"{}:{}\", self.namespace, self.id)\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-theme","src","lib.rs"],"content":"#![warn(missing_docs)]\r\n\r\n//! Theme/Styling library for Maycoon => See `maycoon` crate.\r\n//!\r\n//! Contains themes and widget styles.\r\n\r\n/// Contains the [globals::Globals] struct.\r\npub mod globals;\r\n/// Contains the [id::WidgetId] struct.\r\npub mod id;\r\n/// Contains styling structures.\r\npub mod style;\r\n/// Contains the [theme::Theme] trait and built-in themes.\r\npub mod theme;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-theme","src","style.rs"],"content":"use peniko::{Brush, Color, Gradient};\r\nuse rpds::HashTrieMap;\r\n\r\n/// Styling map for defining widget appearance.\r\n#[derive(Clone, Debug)]\r\npub struct Style {\r\n    map: HashTrieMap<&'static str, StyleVal>,\r\n}\r\n\r\nimpl Style {\r\n    /// Create a new empty style.\r\n    #[inline(always)]\r\n    pub fn new() -> Self {\r\n        Self {\r\n            map: HashTrieMap::new(),\r\n        }\r\n    }\r\n\r\n    /// Create a style from an array of strings and style values.\r\n    #[inline(always)]\r\n    pub fn from_values(values: impl IntoIterator<Item = (&'static str, StyleVal)>) -> Self {\r\n        Self {\r\n            map: HashTrieMap::from_iter(values),\r\n        }\r\n    }\r\n\r\n    /// Insert a style value with the given name into the style map and return the new style.\r\n    #[inline(always)]\r\n    pub fn with_value(self, name: &'static str, value: StyleVal) -> Self {\r\n        Self {\r\n            map: self.map.insert(name, value),\r\n        }\r\n    }\r\n\r\n    /// Get a style value by name. Returns [None] if the value name does not exist.\r\n    #[inline(always)]\r\n    pub fn get(&self, name: &'static str) -> Option<StyleVal> {\r\n        self.map.get(name).cloned()\r\n    }\r\n\r\n    /// Get a color style value by name. Returns [None] if the value name does not exist.\r\n    #[inline(always)]\r\n    pub fn get_color(&self, name: &'static str) -> Option<Color> {\r\n        if let Some(val) = self.map.get(name) {\r\n            match val {\r\n                StyleVal::Color(color) => Some(*color),\r\n                _ => None,\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Get a gradient style value by name. Returns [None] if the value name does not exist.\r\n    #[inline(always)]\r\n    pub fn get_gradient(&self, name: &'static str) -> Option<Gradient> {\r\n        if let Some(val) = self.map.get(name) {\r\n            match val {\r\n                StyleVal::Gradient(gradient) => Some(gradient.clone()),\r\n                _ => None,\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Get a brush style value by name. Returns [None] if the value name does not exist.\r\n    #[inline(always)]\r\n    pub fn get_brush(&self, name: &'static str) -> Option<Brush> {\r\n        if let Some(val) = self.map.get(name) {\r\n            match val {\r\n                StyleVal::Brush(brush) => Some(brush.clone()),\r\n                _ => None,\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Get a float style value by name. Returns [None] if the value name does not exist.\r\n    #[inline(always)]\r\n    pub fn get_float(&self, name: &'static str) -> Option<f32> {\r\n        if let Some(val) = self.map.get(name) {\r\n            match val {\r\n                StyleVal::Float(float) => Some(*float),\r\n                _ => None,\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Get an int style value by name. Returns [None] if the value name does not exist.\r\n    #[inline(always)]\r\n    pub fn get_int(&self, name: &'static str) -> Option<i32> {\r\n        if let Some(val) = self.map.get(name) {\r\n            match val {\r\n                StyleVal::Int(int) => Some(*int),\r\n                _ => None,\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Get an unsized int style value by name. Returns [None] if the value name does not exist.\r\n    #[inline(always)]\r\n    pub fn get_uint(&self, name: &'static str) -> Option<u32> {\r\n        if let Some(val) = self.map.get(name) {\r\n            match val {\r\n                StyleVal::UInt(uint) => Some(*uint),\r\n                _ => None,\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Get a bool style value by name. Returns [None] if the value name does not exist.\r\n    #[inline(always)]\r\n    pub fn get_bool(&self, name: &'static str) -> Option<bool> {\r\n        if let Some(val) = self.map.get(name) {\r\n            match val {\r\n                StyleVal::Bool(bool) => Some(*bool),\r\n                _ => None,\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\nimpl Default for Style {\r\n    #[inline(always)]\r\n    fn default() -> Self {\r\n        Self::new()\r\n    }\r\n}\r\n\r\n/// Default widget styles.\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct DefaultStyles {\r\n    text: DefaultTextStyles,\r\n    container: DefaultContainerStyles,\r\n    interactive: DefaultInteractiveStyles,\r\n}\r\n\r\nimpl DefaultStyles {\r\n    /// Create new default styles with given styles.\r\n    #[inline(always)]\r\n    pub const fn new(\r\n        text: DefaultTextStyles,\r\n        container: DefaultContainerStyles,\r\n        interactive: DefaultInteractiveStyles,\r\n    ) -> Self {\r\n        Self {\r\n            text,\r\n            container,\r\n            interactive,\r\n        }\r\n    }\r\n\r\n    /// Get the default styles for text widgets.\r\n    #[inline(always)]\r\n    pub const fn text(&self) -> &DefaultTextStyles {\r\n        &self.text\r\n    }\r\n\r\n    /// Get the default styles for container widgets.\r\n    #[inline(always)]\r\n    pub const fn container(&self) -> &DefaultContainerStyles {\r\n        &self.container\r\n    }\r\n\r\n    /// Get the default styles for interactive widgets.\r\n    #[inline(always)]\r\n    pub const fn interactive(&self) -> &DefaultInteractiveStyles {\r\n        &self.interactive\r\n    }\r\n}\r\n\r\n/// The default text widget styles.\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct DefaultTextStyles {\r\n    foreground: Color,\r\n    background: Color,\r\n}\r\n\r\nimpl DefaultTextStyles {\r\n    /// Create new default text styles with given colors.\r\n    #[inline(always)]\r\n    pub const fn new(foreground: Color, background: Color) -> Self {\r\n        Self {\r\n            foreground,\r\n            background,\r\n        }\r\n    }\r\n\r\n    /// Get the default foreground color.\r\n    #[inline(always)]\r\n    pub const fn foreground(&self) -> Color {\r\n        self.foreground\r\n    }\r\n\r\n    /// Get the default background color.\r\n    #[inline(always)]\r\n    pub const fn background(&self) -> Color {\r\n        self.background\r\n    }\r\n}\r\n\r\n/// The default container widget styles.\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct DefaultContainerStyles {\r\n    foreground: Color,\r\n    background: Color,\r\n}\r\n\r\nimpl DefaultContainerStyles {\r\n    /// Create new default container styles with given colors.\r\n    #[inline(always)]\r\n    pub const fn new(foreground: Color, background: Color) -> Self {\r\n        Self {\r\n            foreground,\r\n            background,\r\n        }\r\n    }\r\n\r\n    /// Get the default foreground color.\r\n    #[inline(always)]\r\n    pub const fn foreground(&self) -> Color {\r\n        self.foreground\r\n    }\r\n\r\n    /// Get the default background color.\r\n    #[inline(always)]\r\n    pub const fn background(&self) -> Color {\r\n        self.background\r\n    }\r\n}\r\n\r\n/// The default interactive widget styles.\r\n#[derive(Clone, PartialEq, Debug)]\r\npub struct DefaultInteractiveStyles {\r\n    active: Color,\r\n    inactive: Color,\r\n    hover: Color,\r\n    disabled: Color,\r\n}\r\n\r\nimpl DefaultInteractiveStyles {\r\n    /// Create new default interactive styles with given colors.\r\n    #[inline(always)]\r\n    pub const fn new(active: Color, inactive: Color, hover: Color, disabled: Color) -> Self {\r\n        Self {\r\n            active,\r\n            inactive,\r\n            hover,\r\n            disabled,\r\n        }\r\n    }\r\n\r\n    /// Get the default active widget color.\r\n    #[inline(always)]\r\n    pub const fn active(&self) -> Color {\r\n        self.active\r\n    }\r\n\r\n    /// Get the default inactive widget color.\r\n    #[inline(always)]\r\n    pub const fn inactive(&self) -> Color {\r\n        self.inactive\r\n    }\r\n\r\n    /// Get the default on-hover widget color.\r\n    #[inline(always)]\r\n    pub const fn hover(&self) -> Color {\r\n        self.hover\r\n    }\r\n\r\n    /// Get the default disabled widget color.\r\n    #[inline(always)]\r\n    pub const fn disabled(&self) -> Color {\r\n        self.disabled\r\n    }\r\n}\r\n\r\n/// A style value.\r\n#[derive(Clone, Debug)]\r\npub enum StyleVal {\r\n    /// A color style value.\r\n    Color(Color),\r\n    /// A gradient style value.\r\n    Gradient(Gradient),\r\n    /// A brush style value.\r\n    Brush(Brush),\r\n    /// A float style value.\r\n    Float(f32),\r\n    /// An int style value.\r\n    Int(i32),\r\n    /// An unsized int style value.\r\n    UInt(u32),\r\n    /// A bool style value.\r\n    Bool(bool),\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":78},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-theme","src","theme","celeste.rs"],"content":"use peniko::{Color, color::palette};\r\n\r\nuse crate::globals::Globals;\r\nuse crate::id::WidgetId;\r\nuse crate::style::{\r\n    DefaultContainerStyles, DefaultInteractiveStyles, DefaultStyles, DefaultTextStyles, Style,\r\n};\r\nuse crate::theme::Theme;\r\n\r\n/// A smooth and minimalistic theme with a cold blue and purple touch.\r\n#[derive(Debug, Clone)]\r\npub enum CelesteTheme {\r\n    /// Use [CelesteTheme::light] to use the light Celeste theme.\r\n    Light(Globals),\r\n}\r\n\r\nimpl CelesteTheme {\r\n    /// The Light Celeste Theme.\r\n    pub fn light() -> Self {\r\n        Self::Light(Globals::default())\r\n    }\r\n}\r\n\r\nimpl Default for CelesteTheme {\r\n    fn default() -> Self {\r\n        Self::light()\r\n    }\r\n}\r\n\r\nimpl Theme for CelesteTheme {\r\n    fn of(&self, id: WidgetId) -> Option<Style> {\r\n        match id.namespace() {\r\n            \"maycoon-widgets\" => match id.id() {\r\n                \"Text\" => Some(Style::from_values(light::TEXT)),\r\n                \"Button\" => Some(Style::from_values(light::BUTTON)),\r\n                \"Checkbox\" => Some(Style::from_values(light::CHECKBOX)),\r\n                \"Slider\" => Some(Style::from_values(light::SLIDER)),\r\n                _ => None,\r\n            },\r\n            _ => None,\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn defaults(&self) -> DefaultStyles {\r\n        DefaultStyles::new(\r\n            DefaultTextStyles::new(palette::css::BLACK, palette::css::WHITE_SMOKE),\r\n            DefaultContainerStyles::new(palette::css::ANTIQUE_WHITE, palette::css::WHITE),\r\n            DefaultInteractiveStyles::new(\r\n                Color::from_rgb8(130, 150, 230),\r\n                Color::from_rgb8(150, 170, 250),\r\n                Color::from_rgb8(140, 160, 240),\r\n                Color::from_rgb8(110, 110, 110),\r\n            ),\r\n        )\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn window_background(&self) -> Color {\r\n        Color::WHITE\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn globals(&self) -> &Globals {\r\n        match &self {\r\n            CelesteTheme::Light(globals) => globals,\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn globals_mut(&mut self) -> &mut Globals {\r\n        match self {\r\n            CelesteTheme::Light(globals) => globals,\r\n        }\r\n    }\r\n}\r\n\r\nmod light {\r\n    use crate::style::StyleVal;\r\n    use peniko::Color;\r\n    use peniko::color::palette;\r\n\r\n    pub const TEXT: [(&str, StyleVal); 2] = [\r\n        (\"color\", StyleVal::Color(palette::css::BLACK)),\r\n        (\"color_invert\", StyleVal::Color(palette::css::WHITE)),\r\n    ];\r\n\r\n    pub const BUTTON: [(&str, StyleVal); 3] = [\r\n        (\r\n            \"color_idle\",\r\n            StyleVal::Color(Color::from_rgb8(150, 170, 250)),\r\n        ),\r\n        (\r\n            \"color_pressed\",\r\n            StyleVal::Color(Color::from_rgb8(130, 150, 230)),\r\n        ),\r\n        (\r\n            \"color_hovered\",\r\n            StyleVal::Color(Color::from_rgb8(140, 160, 240)),\r\n        ),\r\n    ];\r\n\r\n    pub const CHECKBOX: [(&str, StyleVal); 2] = [\r\n        (\r\n            \"color_checked\",\r\n            StyleVal::Color(Color::from_rgb8(130, 130, 230)),\r\n        ),\r\n        (\r\n            \"color_unchecked\",\r\n            StyleVal::Color(Color::from_rgb8(170, 170, 250)),\r\n        ),\r\n    ];\r\n\r\n    pub const SLIDER: [(&str, StyleVal); 2] = [\r\n        (\"color\", StyleVal::Color(Color::from_rgb8(130, 130, 230))),\r\n        (\r\n            \"color_ball\",\r\n            StyleVal::Color(Color::from_rgb8(170, 170, 250)),\r\n        ),\r\n    ];\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-theme","src","theme","dummy.rs"],"content":"use crate::globals::Globals;\r\nuse crate::id::WidgetId;\r\nuse crate::style::{\r\n    DefaultContainerStyles, DefaultInteractiveStyles, DefaultStyles, DefaultTextStyles, Style,\r\n};\r\nuse crate::theme::Theme;\r\nuse peniko::Color;\r\n\r\n/// A dummy theme that only returns [None] or [Color::WHITE].\r\n///\r\n/// Useful for testing.\r\n#[derive(Debug, Copy, Clone, Default)]\r\npub struct DummyTheme(Globals);\r\n\r\nimpl Theme for DummyTheme {\r\n    fn of(&self, _id: WidgetId) -> Option<Style> {\r\n        None\r\n    }\r\n\r\n    fn defaults(&self) -> DefaultStyles {\r\n        DefaultStyles::new(\r\n            DefaultTextStyles::new(Color::WHITE, Color::WHITE),\r\n            DefaultContainerStyles::new(Color::WHITE, Color::WHITE),\r\n            DefaultInteractiveStyles::new(Color::WHITE, Color::WHITE, Color::WHITE, Color::WHITE),\r\n        )\r\n    }\r\n\r\n    fn window_background(&self) -> Color {\r\n        Color::WHITE\r\n    }\r\n\r\n    fn globals(&self) -> &Globals {\r\n        &self.0\r\n    }\r\n\r\n    fn globals_mut(&mut self) -> &mut Globals {\r\n        &mut self.0\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-theme","src","theme","mod.rs"],"content":"use peniko::Color;\r\nuse std::fmt::Debug;\r\n\r\nuse crate::globals::Globals;\r\nuse crate::id::WidgetId;\r\nuse crate::style::{DefaultStyles, Style};\r\n\r\n/// The Celeste Theme.\r\npub mod celeste;\r\n\r\n/// A dummy theme for testing purposes.\r\npub mod dummy;\r\n\r\n/// Base trait for all themes.\r\npub trait Theme: Debug + 'static {\r\n    /// Return the [Style] of the given widget using its ID.\r\n    /// Returns [None] if the theme does not have styles for the given widget.\r\n    /// In that case, you should use [Theme::defaults] to get widget style defaults.\r\n    fn of(&self, id: WidgetId) -> Option<Style>;\r\n    /// Get the default widget styles.\r\n    fn defaults(&self) -> DefaultStyles;\r\n    /// Get the background color of the window.\r\n    fn window_background(&self) -> Color;\r\n    /// Get global style values.\r\n    fn globals(&self) -> &Globals;\r\n    /// Get mutable global style values.\r\n    fn globals_mut(&mut self) -> &mut Globals;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","build.rs"],"content":"fn main() {\r\n    cfg_aliases::cfg_aliases! {\r\n        web: { target_arch = \"wasm32\" },\r\n        native: { not(target_arch = \"wasm32\") },\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","animator.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout::{LayoutNode, StyleNode};\r\nuse maycoon_core::vgi::Scene;\r\nuse maycoon_core::widget::Widget;\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\nuse std::time::{Duration, Instant};\r\n\r\n/// A widget that animates another widget using an animation function.\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Animator`.\r\npub struct Animator<W: Widget, A: Fn(&mut W, f32) -> Update> {\r\n    start: Instant,\r\n    duration: Duration,\r\n    widget: W,\r\n    animation: A,\r\n}\r\n\r\nimpl<W: Widget, A: Fn(&mut W, f32) -> Update> Animator<W, A> {\r\n    /// Creates a new animator widget with the given duration, child widget and animation function.\r\n    ///\r\n    /// The animation function is called with a value between `0.0` and `1.0` based on the elapsed time since the start of the animation\r\n    /// and the total duration of the animation.\r\n    #[inline(always)]\r\n    pub fn new(duration: Duration, widget: W, animation: A) -> Self {\r\n        Self {\r\n            start: Instant::now(),\r\n            duration,\r\n            widget,\r\n            animation,\r\n        }\r\n    }\r\n}\r\n\r\nimpl<W: Widget, A: Fn(&mut W, f32) -> Update> Widget for Animator<W, A> {\r\n    #[inline(always)]\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        info: &AppInfo,\r\n        context: AppContext,\r\n    ) {\r\n        self.widget.render(scene, theme, layout_node, info, context);\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        self.widget.layout_style()\r\n    }\r\n\r\n    fn update(&mut self, layout: &LayoutNode, context: AppContext, info: &AppInfo) -> Update {\r\n        let elapsed = self.start.elapsed();\r\n\r\n        let mut update = self.widget.update(layout, context, info);\r\n\r\n        if elapsed < self.duration {\r\n            let f = elapsed.as_secs_f32() / self.duration.as_secs_f32();\r\n\r\n            update.insert((self.animation)(&mut self.widget, f));\r\n        }\r\n\r\n        update\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Animator\")\r\n    }\r\n}\r\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","button.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout;\r\nuse maycoon_core::layout::{LayoutNode, LayoutStyle, LengthPercentage, StyleNode};\r\nuse maycoon_core::signal::MaybeSignal;\r\nuse maycoon_core::vgi::kurbo::{Affine, Rect, RoundedRect, RoundedRectRadii, Vec2};\r\nuse maycoon_core::vgi::{Brush, Scene};\r\nuse maycoon_core::widget::{BoxedWidget, Widget, WidgetChildExt, WidgetLayoutExt};\r\nuse maycoon_core::window::{ElementState, MouseButton};\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\n\r\n/// An interactive area with a child widget that runs a closure when pressed.\r\n///\r\n/// See the [counter](https://github.com/maycoon-ui/maycoon/blob/master/examples/counter/src/main.rs) example for how to use it in practice.\r\n///\r\n/// ### Theming\r\n/// Styling the button require following properties:\r\n/// - `color_pressed` -  The color of the button when pressed.\r\n/// - `color_idle` - The color of the button when not pressed and not hovered (idling).\r\n/// - `color_hovered` - The color of the button when hovered on.\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Button`.\r\npub struct Button {\r\n    child: BoxedWidget,\r\n    state: ButtonState,\r\n    on_pressed: MaybeSignal<Update>,\r\n    layout_style: MaybeSignal<LayoutStyle>,\r\n}\r\n\r\nimpl Button {\r\n    /// Create a new button with the given child widget.\r\n    #[inline(always)]\r\n    pub fn new(child: impl Widget + 'static) -> Self {\r\n        Self {\r\n            child: Box::new(child),\r\n            state: ButtonState::Idle,\r\n            on_pressed: MaybeSignal::value(Update::empty()),\r\n            layout_style: LayoutStyle {\r\n                padding: layout::Rect::<LengthPercentage> {\r\n                    left: LengthPercentage::length(12.0),\r\n                    right: LengthPercentage::length(12.0),\r\n                    top: LengthPercentage::length(2.0),\r\n                    bottom: LengthPercentage::length(10.0),\r\n                },\r\n                ..Default::default()\r\n            }\r\n            .into(),\r\n        }\r\n    }\r\n\r\n    /// Sets the function to be called when the button is pressed.\r\n    #[inline(always)]\r\n    pub fn with_on_pressed(mut self, on_pressed: impl Into<MaybeSignal<Update>>) -> Self {\r\n        self.on_pressed = on_pressed.into();\r\n        self\r\n    }\r\n}\r\n\r\nimpl WidgetChildExt for Button {\r\n    #[inline(always)]\r\n    fn set_child(&mut self, child: impl Widget + 'static) {\r\n        self.child = Box::new(child);\r\n    }\r\n}\r\n\r\nimpl WidgetLayoutExt for Button {\r\n    #[inline(always)]\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.layout_style = layout_style.into();\r\n    }\r\n}\r\n\r\nimpl Widget for Button {\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        info: &AppInfo,\r\n        context: AppContext,\r\n    ) {\r\n        let brush = if let Some(style) = theme.of(self.widget_id()) {\r\n            match self.state {\r\n                ButtonState::Idle => Brush::Solid(style.get_color(\"color_idle\").unwrap()),\r\n                ButtonState::Hovered => Brush::Solid(style.get_color(\"color_hovered\").unwrap()),\r\n                ButtonState::Pressed => Brush::Solid(style.get_color(\"color_pressed\").unwrap()),\r\n                ButtonState::Released => Brush::Solid(style.get_color(\"color_hovered\").unwrap()),\r\n            }\r\n        } else {\r\n            Brush::Solid(match self.state {\r\n                ButtonState::Idle => theme.defaults().interactive().inactive(),\r\n                ButtonState::Hovered => theme.defaults().interactive().hover(),\r\n                ButtonState::Pressed => theme.defaults().interactive().active(),\r\n                ButtonState::Released => theme.defaults().interactive().hover(),\r\n            })\r\n        };\r\n\r\n        scene.draw_rounded_rect(\r\n            &brush,\r\n            None,\r\n            None,\r\n            &RoundedRect::from_rect(\r\n                Rect::new(\r\n                    layout_node.layout.location.x as f64,\r\n                    layout_node.layout.location.y as f64,\r\n                    (layout_node.layout.location.x + layout_node.layout.size.width) as f64,\r\n                    (layout_node.layout.location.y + layout_node.layout.size.height) as f64,\r\n                ),\r\n                RoundedRectRadii::from_single_radius(10.0),\r\n            ),\r\n        );\r\n\r\n        {\r\n            theme.globals_mut().invert_text_color = true;\r\n\r\n            let mut child_scene = scene.dyn_clone();\r\n            child_scene.reset();\r\n\r\n            self.child.render(\r\n                child_scene.as_mut(),\r\n                theme,\r\n                &layout_node.children[0],\r\n                info,\r\n                context,\r\n            );\r\n\r\n            scene.append(\r\n                child_scene.as_ref(),\r\n                Some(Affine::translate(Vec2::new(\r\n                    layout_node.layout.location.x as f64,\r\n                    layout_node.layout.location.y as f64,\r\n                ))),\r\n            );\r\n\r\n            theme.globals_mut().invert_text_color = false;\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        StyleNode {\r\n            style: self.layout_style.get().clone(),\r\n            children: vec![self.child.layout_style()],\r\n        }\r\n    }\r\n\r\n    fn update(&mut self, layout: &LayoutNode, _: AppContext, info: &AppInfo) -> Update {\r\n        let mut update = Update::empty();\r\n        let old_state = self.state;\r\n\r\n        // check for hovering\r\n        if let Some(cursor) = info.cursor_pos\r\n            && layout::intersects(cursor, &layout.layout)\r\n        {\r\n            // fixes state going to hover if the button is pressed but not yet released\r\n            if self.state != ButtonState::Pressed {\r\n                self.state = ButtonState::Hovered;\r\n            }\r\n\r\n            // check for click\r\n            for (_, btn, el) in &info.buttons {\r\n                if *btn == MouseButton::Left {\r\n                    match el {\r\n                        ElementState::Pressed => {\r\n                            self.state = ButtonState::Pressed;\r\n                        },\r\n\r\n                        // actually fire the event if the button is released\r\n                        ElementState::Released => {\r\n                            self.state = ButtonState::Released;\r\n                            update |= *self.on_pressed.get();\r\n                        },\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // cursor is not in window, so button is idle\r\n            self.state = ButtonState::Idle;\r\n        }\r\n\r\n        // update on state change, due to re-coloring\r\n        if old_state != self.state {\r\n            update |= Update::DRAW;\r\n        }\r\n\r\n        update\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Button\")\r\n    }\r\n}\r\n\r\n/// The internal state of the button.\r\n#[derive(Copy, Clone, Eq, PartialEq, Debug)]\r\npub enum ButtonState {\r\n    /// The button is idling (inactive).\r\n    Idle,\r\n    /// The cursor is hovering over the button.\r\n    Hovered,\r\n    /// The cursor is hovering over the button and the left click button is pressed.\r\n    Pressed,\r\n    /// The cursor is hovering over the button and the left click button is released.\r\n    /// This is when the `on_pressed` function is called.\r\n    Released,\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":73},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","canvas.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout::{LayoutNode, LayoutStyle, StyleNode};\r\nuse maycoon_core::vgi::Scene;\r\nuse maycoon_core::widget::Widget;\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\n\r\n/// A canvas widget to directly draw to the screen.\r\n///\r\n/// This is a very simplified version of \"your own Widget\" and you should only use it for simple cases.\r\n///\r\n/// ### Theming\r\n/// The canvas cannot be themed, since it does not draw something on itself.\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Canvas`.\r\npub struct Canvas {\r\n    painter: Box<dyn FnMut(&mut dyn Scene, &AppInfo)>,\r\n}\r\n\r\nimpl Canvas {\r\n    /// Create a new Canvas widget from a painter function.\r\n    #[inline(always)]\r\n    pub fn new(painter: impl FnMut(&mut dyn Scene, &AppInfo) + 'static) -> Self {\r\n        Self {\r\n            painter: Box::new(painter),\r\n        }\r\n    }\r\n\r\n    /// Set a painter function and return itself.\r\n    #[inline(always)]\r\n    pub fn with_painter(mut self, painter: impl FnMut(&mut dyn Scene, &AppInfo) + 'static) -> Self {\r\n        self.painter = Box::new(painter);\r\n        self\r\n    }\r\n}\r\n\r\nimpl Widget for Canvas {\r\n    #[inline(always)]\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        _: &mut dyn Theme,\r\n        _: &LayoutNode,\r\n        info: &AppInfo,\r\n        _: AppContext,\r\n    ) {\r\n        let mut canvas = scene.dyn_clone();\r\n        canvas.reset();\r\n\r\n        (self.painter)(canvas.as_mut(), info);\r\n\r\n        scene.append(canvas.as_ref(), None);\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        StyleNode {\r\n            style: LayoutStyle::default(),\r\n            children: Vec::new(),\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn update(&mut self, _: &LayoutNode, _: AppContext, _: &AppInfo) -> Update {\r\n        Update::DRAW | Update::LAYOUT\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Canvas\")\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","checkbox.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout;\r\nuse maycoon_core::layout::{Dimension, LayoutNode, LayoutStyle, LengthPercentageAuto, StyleNode};\r\nuse maycoon_core::signal::MaybeSignal;\r\nuse maycoon_core::vgi::kurbo::{Rect, RoundedRect, RoundedRectRadii, Stroke};\r\nuse maycoon_core::vgi::{Brush, Scene};\r\nuse maycoon_core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon_core::window::{ElementState, MouseButton};\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\nuse nalgebra::Vector2;\r\n\r\n/// A checkbox widget. Changes state when it's clicked.\r\n///\r\n/// See the [checkbox](https://github.com/maycoon-ui/maycoon/blob/master/examples/checkbox/src/main.rs) example for how to use it in practice.\r\n///\r\n/// ### Theming\r\n/// Styling the checkbox requires following properties:\r\n/// - `color_unchecked` -  The color of the checkbox, when it's not checked (inner value is false).\r\n/// - `color_checked` - The color of the checkbox, when it's checked (inner value is true).\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Checkbox`.\r\npub struct Checkbox {\r\n    layout_style: MaybeSignal<LayoutStyle>,\r\n    value: MaybeSignal<bool>,\r\n    on_change: MaybeSignal<Update>,\r\n}\r\n\r\nimpl Checkbox {\r\n    /// Create a new checkbox with the given value.\r\n    ///\r\n    /// The value should be a signal, so it's mutable.\r\n    #[inline(always)]\r\n    pub fn new(value: impl Into<MaybeSignal<bool>>) -> Self {\r\n        Self {\r\n            layout_style: LayoutStyle {\r\n                size: Vector2::<Dimension>::new(Dimension::length(20.0), Dimension::length(20.0)),\r\n                margin: layout::Rect::<LengthPercentageAuto> {\r\n                    left: LengthPercentageAuto::length(0.5),\r\n                    right: LengthPercentageAuto::length(0.5),\r\n                    top: LengthPercentageAuto::length(0.5),\r\n                    bottom: LengthPercentageAuto::length(0.5),\r\n                },\r\n                ..Default::default()\r\n            }\r\n            .into(),\r\n            value: value.into(),\r\n            on_change: Update::empty().into(),\r\n        }\r\n    }\r\n\r\n    /// Sets the value of the checkbox and returns self.\r\n    #[inline(always)]\r\n    pub fn with_value(mut self, value: impl Into<MaybeSignal<bool>>) -> Self {\r\n        self.value = value.into();\r\n        self\r\n    }\r\n\r\n    /// Sets the update value to apply on changes and returns self.\r\n    #[inline(always)]\r\n    pub fn with_on_change(mut self, on_change: impl Into<MaybeSignal<Update>>) -> Self {\r\n        self.on_change = on_change.into();\r\n        self\r\n    }\r\n}\r\n\r\nimpl WidgetLayoutExt for Checkbox {\r\n    #[inline(always)]\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.layout_style = layout_style.into();\r\n    }\r\n}\r\n\r\nimpl Widget for Checkbox {\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        _: &AppInfo,\r\n        _: AppContext,\r\n    ) {\r\n        let checked = *self.value.get();\r\n\r\n        let color = if let Some(style) = theme.of(self.widget_id()) {\r\n            if checked {\r\n                style.get_color(\"color_checked\").unwrap()\r\n            } else {\r\n                style.get_color(\"color_unchecked\").unwrap()\r\n            }\r\n        } else if checked {\r\n            theme.defaults().interactive().active()\r\n        } else {\r\n            theme.defaults().interactive().inactive()\r\n        };\r\n\r\n        scene.draw_rounded_rect(\r\n            &Brush::Solid(color),\r\n            None,\r\n            Some(&Stroke::new(3.0)),\r\n            &RoundedRect::from_rect(\r\n                Rect::new(\r\n                    layout_node.layout.location.x as f64,\r\n                    layout_node.layout.location.y as f64,\r\n                    (layout_node.layout.location.x + layout_node.layout.size.width) as f64,\r\n                    (layout_node.layout.location.y + layout_node.layout.size.height) as f64,\r\n                ),\r\n                RoundedRectRadii::from_single_radius(5.0),\r\n            ),\r\n        );\r\n\r\n        if checked {\r\n            scene.draw_rounded_rect(\r\n                &Brush::Solid(color),\r\n                None,\r\n                None,\r\n                &RoundedRect::from_rect(\r\n                    Rect::new(\r\n                        layout_node.layout.location.x as f64 + 5.0,\r\n                        layout_node.layout.location.y as f64 + 5.0,\r\n                        (layout_node.layout.location.x + layout_node.layout.size.width) as f64\r\n                            - 5.0,\r\n                        (layout_node.layout.location.y + layout_node.layout.size.height) as f64\r\n                            - 5.0,\r\n                    ),\r\n                    RoundedRectRadii::from_single_radius(2.5),\r\n                ),\r\n            );\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        StyleNode {\r\n            style: self.layout_style.get().clone(),\r\n            children: Vec::new(),\r\n        }\r\n    }\r\n\r\n    fn update(&mut self, layout: &LayoutNode, _: AppContext, info: &AppInfo) -> Update {\r\n        let mut update = Update::empty();\r\n\r\n        if let Some(cursor) = info.cursor_pos\r\n            && layout::intersects(cursor, &layout.layout)\r\n        {\r\n            for (_, btn, el) in &info.buttons {\r\n                if btn == &MouseButton::Left && *el == ElementState::Released {\r\n                    update |= *self.on_change.get();\r\n                    update |= Update::DRAW;\r\n\r\n                    if let Some(sig) = self.value.as_signal() {\r\n                        let checked = *sig.get();\r\n                        sig.set(!checked);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        update\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Checkbox\")\r\n    }\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":63},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","container.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout::{LayoutNode, LayoutStyle, StyleNode};\r\nuse maycoon_core::signal::MaybeSignal;\r\nuse maycoon_core::vgi::Scene;\r\nuse maycoon_core::widget::{BoxedWidget, Widget, WidgetChildrenExt, WidgetLayoutExt};\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\n\r\n/// A container widget that can display and layout multiple child widgets.\r\n///\r\n/// The layout of the children (row, column, etc.) depends on the [LayoutStyle] of the container.\r\n///\r\n/// See the [counter](https://github.com/maycoon-ui/maycoon/blob/master/examples/counter/src/main.rs) example for how to use it in practice.\r\n///\r\n/// ### Theming\r\n/// The container widget doesn't actually draw anything but the child widgets, so theming is useless.\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Container`.\r\n#[derive(Default)]\r\npub struct Container {\r\n    style: MaybeSignal<LayoutStyle>,\r\n    children: Vec<BoxedWidget>,\r\n}\r\n\r\nimpl Container {\r\n    /// Creates a new container with given children.\r\n    #[inline(always)]\r\n    pub fn new(children: Vec<BoxedWidget>) -> Self {\r\n        Self {\r\n            style: LayoutStyle::default().into(),\r\n            children: children.into_iter().collect(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl WidgetChildrenExt for Container {\r\n    #[inline(always)]\r\n    fn set_children(&mut self, children: Vec<BoxedWidget>) {\r\n        self.children = children.into_iter().collect();\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn add_child(&mut self, child: impl Widget + 'static) {\r\n        self.children.push(Box::new(child));\r\n    }\r\n}\r\n\r\nimpl WidgetLayoutExt for Container {\r\n    #[inline(always)]\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.style = layout_style.into();\r\n    }\r\n}\r\n\r\nimpl Widget for Container {\r\n    #[inline(always)]\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        info: &AppInfo,\r\n        context: AppContext,\r\n    ) {\r\n        for (i, child) in self.children.iter_mut().enumerate() {\r\n            child.render(\r\n                scene,\r\n                theme,\r\n                &layout_node.children[i],\r\n                info,\r\n                context.clone(),\r\n            );\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        let style = self.style.get().clone();\r\n\r\n        let mut children = Vec::with_capacity(self.children.len());\r\n\r\n        for child in &self.children {\r\n            children.push(child.layout_style());\r\n        }\r\n\r\n        StyleNode { style, children }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn update(&mut self, layout: &LayoutNode, context: AppContext, info: &AppInfo) -> Update {\r\n        let mut update = Update::empty();\r\n\r\n        for (i, child) in self.children.iter_mut().enumerate() {\r\n            update.insert(child.update(&layout.children[i], context.clone(), info));\r\n        }\r\n\r\n        update\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Container\")\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","fetcher.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout::{LayoutNode, LayoutStyle, StyleNode};\r\nuse maycoon_core::tasks::fetcher::Fetcher;\r\nuse maycoon_core::vgi::Scene;\r\nuse maycoon_core::widget::Widget;\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\nuse std::future::Future;\r\n\r\n/// A widget to build an inner widget from an asynchronous task.\r\n/// This is a [Widget] version of [Fetcher].\r\n///\r\n/// It is similar to the [FutureBuilder](https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html) from Flutter.\r\n///\r\n/// ### Async + UI\r\n/// When working with a future, you usually need to block on it to produce a value.\r\n/// This would however block the main thread and freeze the whole application temporarily until the task is done.\r\n/// Blocking is less than ideal for any UI application,\r\n/// so the [Fetcher] and [WidgetFetcher] structures exist to run a task in the background,\r\n/// while still providing the user with a smooth interface experience.\r\n///\r\n/// The [WidgetFetcher] will spawn the given task in the background.\r\n/// While the task is still running/loading, the fetcher will still be able to produce a widget via a given factory function.\r\n/// This factory function takes `Option<T>` as an argument, where `T` is the output of the spawned task.\r\n/// If the task is not ready yet, the factory will be called with `None`, otherwise it will be called with `Some(T)`.\r\n///\r\n/// ### Spawning the task\r\n/// By default, the task is spawned inside the [TaskRunner](maycoon_core::tasks::runner::TaskRunner) in a non-blocking manner.\r\n/// If you want to spawn a blocking task (which is however, only supported on native platforms), use [WidgetFetcher::new_blocking]\r\n///\r\n/// **NOTE:** If the future is spawned on a thread pool or not,\r\n/// is up to the [TaskRunner](maycoon_core::tasks::runner::TaskRunner) implementation.\r\n/// Blocking tasks will always be spawned on a thread pool.\r\n///\r\n/// ### Note for the Web\r\n/// On the web, blocking a task is not possible and will freeze the browser,\r\n/// so only futures can be spawned.\r\n/// Furthermore, the futures will be executed on the local thread,\r\n/// since WebAssembly doesn't support threading out-of-the-box yet.\r\n///\r\n/// ### Workflow of a [WidgetFetcher].\r\n/// 1. Run the task in the background using the [TaskRunner](tasks::runner::TaskRunner).\r\n/// 2. Construct the widget with [None] passed into the factory function (while task is still loading).\r\n/// 3. Once the task is done, the UI is updated with the new result and an [Update] is triggered.\r\n///\r\n/// ### Theming\r\n/// The widget itself only draws the underlying widget, so theming is useless.\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:WidgetFetcher`.\r\npub struct WidgetFetcher<T: Send + 'static, W: Widget> {\r\n    fetcher: Fetcher<T, W>,\r\n    update: Update,\r\n}\r\n\r\nimpl<T: Send + 'static, W: Widget> WidgetFetcher<T, W> {\r\n    /// Creates a new [WidgetFetcher] with parameters:\r\n    /// - `future`: The future to execute.\r\n    /// - `update`: The update to trigger when the data is updated (when loading is done).\r\n    /// - `render`: The function to render the widget. It takes a possible task result as the only parameter.\r\n    ///\r\n    /// Unlike [WidgetFetcher::new_blocking]. this will spawn a future in the background.\r\n    /// It's up to the task runner implementation, if the task is spawned on a thread pool or not.\r\n    #[inline(always)]\r\n    pub fn new<Fut>(future: Fut, render: impl Fn(Option<T>) -> W + 'static, update: Update) -> Self\r\n    where\r\n        Fut: Future<Output = T> + Send + 'static,\r\n    {\r\n        Self {\r\n            fetcher: Fetcher::spawn(future, render),\r\n            update,\r\n        }\r\n    }\r\n\r\n    /// Creates a new [WidgetFetcher] with parameters:\r\n    /// - `func`: The blocking task to execute.\r\n    /// - `update`: The update to trigger when the data is updated (when loading is done).\r\n    /// - `render`: The function to render the widget. It takes a possible task result as the only parameter.\r\n    ///\r\n    /// Unlike [WidgetFetcher::new], this takes a function which will be run on a separate thread pool.\r\n    /// This is only supported on native platforms.\r\n    #[inline(always)]\r\n    #[cfg(native)]\r\n    pub fn new_blocking<F>(\r\n        func: F,\r\n        render: impl Fn(Option<T>) -> W + 'static,\r\n        update: Update,\r\n    ) -> Self\r\n    where\r\n        F: Fn() -> T + Send + 'static,\r\n    {\r\n        Self {\r\n            fetcher: Fetcher::spawn_blocking(func, render),\r\n            update,\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T: Send + 'static, W: Widget> Widget for WidgetFetcher<T, W> {\r\n    #[inline(always)]\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        info: &AppInfo,\r\n        context: AppContext,\r\n    ) {\r\n        if let Some(widget) = self.fetcher.value_mut() {\r\n            widget.render(scene, theme, layout_node, info, context.clone())\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        if let Some(widget) = self.fetcher.value_ref() {\r\n            widget.layout_style()\r\n        } else {\r\n            StyleNode {\r\n                style: LayoutStyle::default(),\r\n                children: Vec::new(),\r\n            }\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn update(&mut self, layout: &LayoutNode, context: AppContext, info: &AppInfo) -> Update {\r\n        let mut update = Update::empty();\r\n\r\n        // Make sure to update the widget if the task is about to be polled\r\n        if self.fetcher.is_ready() {\r\n            update.insert(self.update);\r\n        }\r\n\r\n        let widget = self.fetcher.fetch();\r\n\r\n        widget.update(layout, context, info) | update\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"WidgetFetcher\")\r\n    }\r\n}\r\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","gesture_detector.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout;\r\nuse maycoon_core::layout::{LayoutNode, StyleNode};\r\nuse maycoon_core::signal::MaybeSignal;\r\nuse maycoon_core::vgi::Scene;\r\nuse maycoon_core::widget::{BoxedWidget, Widget};\r\nuse maycoon_core::window::{ElementState, MouseButton};\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\n\r\n/// A widget to detect gestures like pressing or releasing the left mouse button.\r\n/// It can also contain a child widget.\r\n///\r\n/// The [GestureDetector] has different callbacks that are called on different events:\r\n/// - `on_press` is called when the left mouse button is pressed.\r\n/// - `on_release` is called when the left mouse button is released.\r\n/// - `on_hover` is called when the mouse cursor hovers over the widget.\r\n///\r\n/// ### Theming\r\n/// The [GestureDetector] should not be themed and does not draw anything on itself.\r\n/// It just contains the given child widget.\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:GestureDetector`.\r\npub struct GestureDetector {\r\n    child: BoxedWidget,\r\n    on_press: MaybeSignal<Update>,\r\n    on_release: MaybeSignal<Update>,\r\n    on_hover: MaybeSignal<Update>,\r\n}\r\n\r\nimpl GestureDetector {\r\n    /// Creates a new [GestureDetector] with the given child widget.\r\n    #[inline(always)]\r\n    pub fn new(child: impl Widget + 'static) -> Self {\r\n        Self {\r\n            child: Box::new(child),\r\n            on_press: MaybeSignal::value(Update::empty()),\r\n            on_release: MaybeSignal::value(Update::empty()),\r\n            on_hover: MaybeSignal::value(Update::empty()),\r\n        }\r\n    }\r\n\r\n    /// Sets the child widget of the [GestureDetector] and returns self.\r\n    #[inline(always)]\r\n    pub fn with_child(mut self, child: impl Widget + 'static) -> Self {\r\n        self.child = Box::new(child);\r\n        self\r\n    }\r\n\r\n    /// Sets the `on_press` callback of the [GestureDetector] and returns self.\r\n    #[inline(always)]\r\n    pub fn with_on_press(mut self, on_press: impl Into<MaybeSignal<Update>>) -> Self {\r\n        self.on_press = on_press.into();\r\n        self\r\n    }\r\n\r\n    /// Sets the `on_release` callback of the [GestureDetector] and returns self.\r\n    #[inline(always)]\r\n    pub fn with_on_release(mut self, on_release: impl Into<MaybeSignal<Update>>) -> Self {\r\n        self.on_release = on_release.into();\r\n        self\r\n    }\r\n\r\n    /// Sets the `on_hover` callback of the [GestureDetector] and returns self.\r\n    #[inline(always)]\r\n    pub fn with_on_hover(mut self, on_hover: impl Into<MaybeSignal<Update>>) -> Self {\r\n        self.on_hover = on_hover.into();\r\n        self\r\n    }\r\n\r\n    /// Call the `on_hover` callback of the [GestureDetector].\r\n    #[inline(always)]\r\n    pub fn on_hover(&mut self) -> Update {\r\n        *self.on_hover.get()\r\n    }\r\n\r\n    /// Call the `on_press` callback of the [GestureDetector].\r\n    #[inline(always)]\r\n    pub fn on_press(&mut self) -> Update {\r\n        *self.on_press.get()\r\n    }\r\n\r\n    /// Call the `on_release` callback of the [GestureDetector].\r\n    #[inline(always)]\r\n    pub fn on_release(&mut self) -> Update {\r\n        *self.on_release.get()\r\n    }\r\n}\r\n\r\nimpl Widget for GestureDetector {\r\n    #[inline(always)]\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        info: &AppInfo,\r\n        context: AppContext,\r\n    ) {\r\n        self.child.render(scene, theme, layout_node, info, context)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        self.child.layout_style()\r\n    }\r\n\r\n    fn update(&mut self, layout: &LayoutNode, context: AppContext, info: &AppInfo) -> Update {\r\n        let mut update = Update::empty();\r\n\r\n        if let Some(cursor) = info.cursor_pos\r\n            && layout::intersects(cursor, &layout.layout)\r\n        {\r\n            update |= self.on_hover();\r\n\r\n            // check for click\r\n            for (_, btn, el) in &info.buttons {\r\n                if *btn == MouseButton::Left {\r\n                    match el {\r\n                        ElementState::Pressed => {\r\n                            update |= self.on_press();\r\n                        },\r\n\r\n                        ElementState::Released => {\r\n                            update |= self.on_release();\r\n                        },\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        update |= self.child.update(layout, context, info);\r\n\r\n        update\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"GestureDetector\")\r\n    }\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","icon","mod.rs"],"content":"use maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout::{Dimension, LayoutNode, LayoutStyle, StyleNode};\r\nuse maycoon_core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\nuse nalgebra::Vector2;\r\n\r\nuse crate::icon::svg::SvgIcon;\r\nuse maycoon_core::app::context::AppContext;\r\nuse maycoon_core::signal::MaybeSignal;\r\nuse maycoon_core::vgi::Scene;\r\nuse maycoon_core::vgi::kurbo::{Affine, Vec2};\r\n\r\n/// Contains the [SvgIcon] struct for representing a rendered SVG Icon.\r\npub mod svg;\r\n\r\n/// A simple icon widget to display SVG icons using [vello_svg] and [usvg].\r\n///\r\n/// ### Theming\r\n/// The widget itself only draws the underlying icon, so theming is useless.\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Icon`.\r\npub struct Icon {\r\n    layout_style: MaybeSignal<LayoutStyle>,\r\n    icon: MaybeSignal<SvgIcon>,\r\n}\r\n\r\nimpl Icon {\r\n    /// Creates a new icon widget from the given svg icon.\r\n    #[inline(always)]\r\n    pub fn new(icon: impl Into<MaybeSignal<SvgIcon>>) -> Self {\r\n        Self {\r\n            layout_style: LayoutStyle {\r\n                size: Vector2::new(Dimension::length(8.0), Dimension::length(8.0)),\r\n                ..Default::default()\r\n            }\r\n            .into(),\r\n            icon: icon.into(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Widget for Icon {\r\n    #[inline(always)]\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        _: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        _: &AppInfo,\r\n        _: AppContext,\r\n    ) {\r\n        let icon = self.icon.get();\r\n\r\n        // The size is divided, as otherwise the icon would be either too large (with 1.0) or too tiny (with 0.1 somehow getting converted to 0.0)\r\n        let affine = Affine::scale_non_uniform(\r\n            layout_node.layout.size.width as f64 / 100.0,\r\n            layout_node.layout.size.height as f64 / 100.0,\r\n        )\r\n        .then_translate(Vec2::new(\r\n            layout_node.layout.location.x as f64,\r\n            layout_node.layout.location.y as f64,\r\n        ));\r\n\r\n        scene.draw_svg(icon.tree(), Some(affine));\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        StyleNode {\r\n            style: self.layout_style.get().clone(),\r\n            children: Vec::new(),\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn update(&mut self, _: &LayoutNode, _: AppContext, _: &AppInfo) -> Update {\r\n        Update::empty()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Icon\")\r\n    }\r\n}\r\n\r\nimpl WidgetLayoutExt for Icon {\r\n    #[inline(always)]\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.layout_style = layout_style.into();\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","icon","svg.rs"],"content":"use maycoon_core::vgi::svg::{Error, Options, Tree};\r\n\r\n/// An SVG icon rendered.\r\npub struct SvgIcon(Tree);\r\n\r\nimpl SvgIcon {\r\n    /// Creates a new icon from the given SVG source.\r\n    ///\r\n    /// Returns [Err] if the SVG could not be parsed.\r\n    #[inline(always)]\r\n    pub fn new(source: impl AsRef<[u8]>) -> Result<Self, Error> {\r\n        Ok(Self(Tree::from_data(source.as_ref(), &Options::default())?))\r\n    }\r\n\r\n    /// Creates a new icon from the given SVG source as string.\r\n    ///\r\n    /// Returns [Err] if the SVG could not be parsed.\r\n    #[inline(always)]\r\n    pub fn new_str(source: impl AsRef<str>) -> Result<Self, Error> {\r\n        Ok(Self(Tree::from_str(source.as_ref(), &Options::default())?))\r\n    }\r\n\r\n    /// Returns the underlying [Tree].\r\n    #[inline(always)]\r\n    pub const fn tree(&self) -> &Tree {\r\n        &self.0\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","image.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout::{LayoutNode, LayoutStyle, StyleNode};\r\nuse maycoon_core::signal::MaybeSignal;\r\nuse maycoon_core::vgi::{ImageBrush, ImageData, Scene};\r\nuse maycoon_core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\nuse nalgebra::Vector2;\r\n\r\n/// An image widget. Pretty self-explanatory.\r\n///\r\n/// See the [image](https://github.com/maycoon-ui/maycoon/blob/master/examples/image/src/main.rs) example for how to use it in practice.\r\n///\r\n/// ### Theming\r\n/// The widget itself only draws the underlying image, so theming is useless.\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Image`.\r\npub struct Image {\r\n    image: MaybeSignal<ImageData>,\r\n    style: MaybeSignal<LayoutStyle>,\r\n}\r\n\r\nimpl Image {\r\n    /// Create an image widget from the given [ImageData].\r\n    #[inline(always)]\r\n    pub fn new(image: impl Into<MaybeSignal<ImageData>>) -> Self {\r\n        Self {\r\n            image: image.into(),\r\n            style: LayoutStyle::default().into(),\r\n        }\r\n    }\r\n\r\n    /// Set the image.\r\n    #[inline(always)]\r\n    pub fn with_image(mut self, image: impl Into<MaybeSignal<ImageData>>) -> Self {\r\n        self.image = image.into();\r\n        self\r\n    }\r\n}\r\n\r\nimpl WidgetLayoutExt for Image {\r\n    #[inline(always)]\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.style = layout_style.into();\r\n    }\r\n}\r\n\r\nimpl Widget for Image {\r\n    #[inline(always)]\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        _: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        _: &AppInfo,\r\n        _: AppContext,\r\n    ) {\r\n        let image = self.image.get();\r\n        let brush = ImageBrush::new(image.clone());\r\n\r\n        scene.draw_image(\r\n            &brush,\r\n            None,\r\n            Vector2::new(layout_node.layout.location.x, layout_node.layout.location.y),\r\n        );\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        StyleNode {\r\n            style: self.style.get().clone(),\r\n            children: Vec::new(),\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn update(&mut self, _: &LayoutNode, _: AppContext, _: &AppInfo) -> Update {\r\n        Update::empty()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Image\")\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","lib.rs"],"content":"#![warn(missing_docs)]\r\n\r\n//! Widget library for Maycoon => See `maycoon` crate.\r\n//!\r\n//! Contains a collection of beautiful maycoon widgets.\r\n\r\n/// Contains the [text::Text] widget.\r\npub mod text;\r\n\r\n/// Contains the [button::Button] widget.\r\npub mod button;\r\n\r\n/// Contains the [container::Container] widget.\r\npub mod container;\r\n\r\n/// Contains the [image::Image] widget.\r\npub mod image;\r\n\r\n/// Contains the [checkbox::Checkbox] widget.\r\npub mod checkbox;\r\n\r\n/// Contains the [slider::Slider] widget.\r\npub mod slider;\r\n\r\n/// Contains the [switch::Switch] widget.\r\npub mod switch;\r\n\r\n/// Contains the [fetcher::WidgetFetcher] widget.\r\npub mod fetcher;\r\n\r\n/// Contains the [canvas::Canvas] widget.\r\n#[cfg(feature = \"canvas\")]\r\npub mod canvas;\r\n\r\n/// Contains the [gesture_detector::GestureDetector] widget.\r\npub mod gesture_detector;\r\n\r\n/// Contains the [icon::Icon] widget.\r\n#[cfg(feature = \"svg\")]\r\npub mod icon;\r\n\r\n/// Contains the [animator::Animator] widget and associated structures.\r\npub mod animator;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","slider.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout;\r\nuse maycoon_core::layout::{Dimension, LayoutNode, LayoutStyle, LengthPercentageAuto, StyleNode};\r\nuse maycoon_core::signal::MaybeSignal;\r\nuse maycoon_core::vgi::kurbo::{Circle, Point, Rect, RoundedRect, RoundedRectRadii};\r\nuse maycoon_core::vgi::{Brush, Scene};\r\nuse maycoon_core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon_core::window::MouseButton;\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\nuse nalgebra::Vector2;\r\n\r\n/// A slider widget to control a floating point value between `0.0` and `1.0`.\r\n///\r\n/// ### Theming\r\n/// You can style the slider using following properties:\r\n/// - `color` - The color of the slider bar.\r\n/// - `color_ball` - The color of the slider ball.\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Slider`.\r\npub struct Slider {\r\n    layout_style: MaybeSignal<LayoutStyle>,\r\n    value: MaybeSignal<f32>,\r\n    on_change: MaybeSignal<Update>,\r\n    dragging: bool,\r\n}\r\n\r\nimpl Slider {\r\n    /// Create a new Slider widget from a value (should be a signal) and an `on_change` callback.\r\n    #[inline(always)]\r\n    pub fn new(value: impl Into<MaybeSignal<f32>>) -> Self {\r\n        Self {\r\n            layout_style: LayoutStyle {\r\n                size: Vector2::<Dimension>::new(Dimension::length(100.0), Dimension::length(10.0)),\r\n                margin: layout::Rect::<LengthPercentageAuto> {\r\n                    left: LengthPercentageAuto::length(10.0),\r\n                    right: LengthPercentageAuto::length(0.0),\r\n                    top: LengthPercentageAuto::length(10.0),\r\n                    bottom: LengthPercentageAuto::length(10.0),\r\n                },\r\n                ..Default::default()\r\n            }\r\n            .into(),\r\n            value: value.into(),\r\n            on_change: MaybeSignal::value(Update::empty()),\r\n            dragging: false,\r\n        }\r\n    }\r\n\r\n    /// Sets the layout style of the slider and returns itself.\r\n    #[inline(always)]\r\n    pub fn with_value(mut self, value: impl Into<MaybeSignal<f32>>) -> Self {\r\n        self.value = value.into();\r\n        self\r\n    }\r\n\r\n    /// Sets the function to be called when the slider is clicked/changed.\r\n    #[inline(always)]\r\n    pub fn with_on_change(mut self, on_change: impl Into<MaybeSignal<Update>>) -> Self {\r\n        self.on_change = on_change.into();\r\n        self\r\n    }\r\n}\r\n\r\nimpl WidgetLayoutExt for Slider {\r\n    #[inline(always)]\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.layout_style = layout_style.into();\r\n    }\r\n}\r\n\r\nimpl Widget for Slider {\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        _: &AppInfo,\r\n        _: AppContext,\r\n    ) {\r\n        let value = *self.value.get();\r\n\r\n        let brush = if let Some(style) = theme.of(self.widget_id()) {\r\n            Brush::Solid(style.get_color(\"color\").unwrap())\r\n        } else {\r\n            Brush::Solid(theme.defaults().interactive().inactive())\r\n        };\r\n\r\n        let ball_brush = if let Some(style) = theme.of(self.widget_id()) {\r\n            Brush::Solid(style.get_color(\"color_ball\").unwrap())\r\n        } else {\r\n            Brush::Solid(theme.defaults().interactive().active())\r\n        };\r\n\r\n        let circle_radius = layout_node.layout.size.height as f64 / 1.15;\r\n\r\n        scene.draw_rounded_rect(\r\n            &brush,\r\n            None,\r\n            None,\r\n            &RoundedRect::from_rect(\r\n                Rect::new(\r\n                    layout_node.layout.location.x as f64,\r\n                    layout_node.layout.location.y as f64,\r\n                    (layout_node.layout.location.x + layout_node.layout.size.width) as f64,\r\n                    (layout_node.layout.location.y + layout_node.layout.size.height) as f64,\r\n                ),\r\n                RoundedRectRadii::from_single_radius(20.0),\r\n            ),\r\n        );\r\n\r\n        scene.draw_circle(\r\n            &ball_brush,\r\n            None,\r\n            None,\r\n            &Circle::new(\r\n                Point::new(\r\n                    (layout_node.layout.location.x + layout_node.layout.size.width * value) as f64,\r\n                    (layout_node.layout.location.y + layout_node.layout.size.height / 2.0) as f64,\r\n                ),\r\n                circle_radius,\r\n            ),\r\n        );\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        StyleNode {\r\n            style: self.layout_style.get().clone(),\r\n            children: Vec::new(),\r\n        }\r\n    }\r\n\r\n    fn update(&mut self, layout: &LayoutNode, _: AppContext, info: &AppInfo) -> Update {\r\n        let mut update = Update::empty();\r\n\r\n        if let Some(cursor) = info.cursor_pos\r\n            && layout::intersects(cursor, &layout.layout)\r\n        {\r\n            for (_, btn, el_state) in &info.buttons {\r\n                if btn == &MouseButton::Left && el_state.is_pressed() {\r\n                    self.dragging = el_state.is_pressed();\r\n                }\r\n            }\r\n\r\n            if self.dragging {\r\n                let new_value = (cursor.x - layout.layout.location.x) / layout.layout.size.width;\r\n\r\n                if let Some(sig) = self.value.as_signal() {\r\n                    sig.set(new_value);\r\n                }\r\n\r\n                update.insert(*self.on_change.get());\r\n                update.insert(Update::DRAW);\r\n            }\r\n        } else {\r\n            self.dragging = false;\r\n        }\r\n\r\n        update\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Slider\")\r\n    }\r\n}\r\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":61},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","switch.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout;\r\nuse maycoon_core::layout::{Dimension, LayoutNode, LayoutStyle, LengthPercentageAuto, StyleNode};\r\nuse maycoon_core::signal::MaybeSignal;\r\nuse maycoon_core::vgi::kurbo::{Circle, Point, Rect, RoundedRect, RoundedRectRadii, Stroke};\r\nuse maycoon_core::vgi::{Brush, Scene};\r\nuse maycoon_core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon_core::window::{ElementState, MouseButton};\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\nuse nalgebra::Vector2;\r\n\r\n/// A switch widget to toggle between two states.\r\n///\r\n/// Similar to a checkbox, but with slightly different visuals.\r\n///\r\n/// See the [switch](https://github.com/maycoon-ui/maycoon/blob/master/examples/switch/src/main.rs) example for how to use it in practice.\r\n///\r\n/// ### Theming\r\n/// Styling the checkbox requires following properties:\r\n/// - `color_unchecked` -  The color of the switch, when it's not checked (inner value is false).\r\n/// - `color_checked` - The color of the switch, when it's checked (inner value is true).\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Switch`.\r\npub struct Switch {\r\n    layout: MaybeSignal<LayoutStyle>,\r\n    value: MaybeSignal<bool>,\r\n    on_change: MaybeSignal<Update>,\r\n}\r\n\r\nimpl Switch {\r\n    /// Create a new switch with the given value.\r\n    ///\r\n    /// The value should be a signal, so it's mutable.\r\n    #[inline(always)]\r\n    pub fn new(value: impl Into<MaybeSignal<bool>>) -> Self {\r\n        Self {\r\n            layout: LayoutStyle {\r\n                size: Vector2::new(Dimension::length(60.0), Dimension::length(30.0)),\r\n                margin: layout::Rect::<LengthPercentageAuto> {\r\n                    left: LengthPercentageAuto::length(2.5),\r\n                    right: LengthPercentageAuto::length(2.5),\r\n                    top: LengthPercentageAuto::length(2.5),\r\n                    bottom: LengthPercentageAuto::length(2.5),\r\n                },\r\n                ..Default::default()\r\n            }\r\n            .into(),\r\n            value: value.into(),\r\n            on_change: Update::empty().into(),\r\n        }\r\n    }\r\n\r\n    /// Sets the value of the checkbox and returns self.\r\n    #[inline(always)]\r\n    pub fn with_value(mut self, value: impl Into<MaybeSignal<bool>>) -> Self {\r\n        self.value = value.into();\r\n        self\r\n    }\r\n\r\n    /// Sets the update value to apply on changes and returns self.\r\n    #[inline(always)]\r\n    pub fn with_on_change(mut self, update: impl Into<MaybeSignal<Update>>) -> Self {\r\n        self.on_change = update.into();\r\n        self\r\n    }\r\n}\r\n\r\nimpl WidgetLayoutExt for Switch {\r\n    #[inline(always)]\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.layout = layout_style.into();\r\n    }\r\n}\r\n\r\nimpl Widget for Switch {\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        _: &AppInfo,\r\n        _: AppContext,\r\n    ) {\r\n        let checked = *self.value.get();\r\n\r\n        let color = if let Some(style) = theme.of(self.widget_id()) {\r\n            if checked {\r\n                style.get_color(\"color_checked\").unwrap()\r\n            } else {\r\n                style.get_color(\"color_unchecked\").unwrap()\r\n            }\r\n        } else if checked {\r\n            theme.defaults().interactive().active()\r\n        } else {\r\n            theme.defaults().interactive().inactive()\r\n        };\r\n\r\n        scene.draw_rounded_rect(\r\n            &Brush::Solid(color),\r\n            None,\r\n            Some(&Stroke::new(5.0)),\r\n            &RoundedRect::from_rect(\r\n                Rect::new(\r\n                    layout_node.layout.location.x as f64,\r\n                    layout_node.layout.location.y as f64,\r\n                    (layout_node.layout.location.x + layout_node.layout.size.width) as f64,\r\n                    (layout_node.layout.location.y + layout_node.layout.size.height) as f64,\r\n                ),\r\n                RoundedRectRadii::from_single_radius(60.0),\r\n            ),\r\n        );\r\n\r\n        let offset = if checked { 15.0 } else { -15.0 };\r\n\r\n        scene.draw_circle(\r\n            &Brush::Solid(color),\r\n            None,\r\n            None,\r\n            &Circle::new(\r\n                Point::new(\r\n                    (layout_node.layout.location.x + (layout_node.layout.size.width / 2.0)) as f64\r\n                        + offset,\r\n                    (layout_node.layout.location.y + (layout_node.layout.size.height / 2.0)) as f64,\r\n                ),\r\n                10.0,\r\n            ),\r\n        );\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn layout_style(&self) -> StyleNode {\r\n        StyleNode {\r\n            style: self.layout.get().clone(),\r\n            children: Vec::new(),\r\n        }\r\n    }\r\n\r\n    fn update(&mut self, layout: &LayoutNode, _: AppContext, info: &AppInfo) -> Update {\r\n        let mut update = Update::empty();\r\n\r\n        if let Some(cursor) = info.cursor_pos\r\n            && layout::intersects(cursor, &layout.layout)\r\n        {\r\n            for (_, btn, el) in &info.buttons {\r\n                if btn == &MouseButton::Left && *el == ElementState::Released {\r\n                    update |= *self.on_change.get();\r\n                    update |= Update::DRAW;\r\n\r\n                    if let Some(sig) = self.value.as_signal() {\r\n                        let checked = *sig.get();\r\n                        sig.set(!checked);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        update\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Switch\")\r\n    }\r\n}\r\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","maycoon-widgets","src","text.rs"],"content":"use maycoon_core::app::context::AppContext;\r\nuse maycoon_core::app::info::AppInfo;\r\nuse maycoon_core::app::update::Update;\r\nuse maycoon_core::layout;\r\nuse maycoon_core::layout::{Dimension, LayoutNode, LayoutStyle, StyleNode};\r\nuse maycoon_core::signal::MaybeSignal;\r\nuse maycoon_core::vgi::{Brush, Scene};\r\nuse maycoon_core::widget::{Widget, WidgetLayoutExt};\r\nuse maycoon_theme::id::WidgetId;\r\nuse maycoon_theme::theme::Theme;\r\nuse nalgebra::Vector2;\r\nuse std::ops::Deref;\r\n\r\n/// Displays the given text with optional font, size and hinting.\r\n///\r\n/// See the [hello-world](https://github.com/maycoon-ui/maycoon/blob/master/examples/hello-world/src/main.rs) example for how to use it in practice.\r\n///\r\n/// ### Theming\r\n/// You can style the text with the following properties:\r\n/// - `color` - The color of the text.\r\n/// - `color_invert` - The color to use when the `invert_color` property is set to `true` in the theme [Globals].\r\n///\r\n/// The [WidgetId] is equal to `maycoon-widgets:Text`.\r\n///\r\n/// [Globals]: maycoon_theme::globals::Globals\r\npub struct Text {\r\n    style: MaybeSignal<LayoutStyle>,\r\n    text: MaybeSignal<String>,\r\n    font: MaybeSignal<Option<String>>,\r\n    font_size: MaybeSignal<f32>,\r\n    line_gap: MaybeSignal<f32>,\r\n    wrap: MaybeSignal<bool>,\r\n    hinting: MaybeSignal<bool>,\r\n    max_width: f32,\r\n}\r\n\r\nimpl Text {\r\n    /// Create a new text widget with the given text.\r\n    #[inline(always)]\r\n    pub fn new(text: impl Into<MaybeSignal<String>>) -> Self {\r\n        Self {\r\n            style: LayoutStyle::default().into(),\r\n            text: text.into(),\r\n            font: None.into(),\r\n            font_size: 30.0.into(),\r\n            line_gap: 7.5.into(),\r\n            wrap: true.into(),\r\n            hinting: true.into(),\r\n            max_width: 0.0,\r\n        }\r\n    }\r\n\r\n    /// Set whether to wrap the text.\r\n    #[inline(always)]\r\n    pub fn with_wrap(mut self, linebreaks: impl Into<MaybeSignal<bool>>) -> Self {\r\n        self.wrap = linebreaks.into();\r\n        self\r\n    }\r\n\r\n    /// Set the hinting of the text.\r\n    ///\r\n    /// Hinting adjusts the display of an outline font so that it lines up with a rasterized grid.\r\n    /// At low screen resolutions and font size, hinting can produce clearer text.\r\n    #[inline(always)]\r\n    pub fn with_hinting(mut self, hinting: impl Into<MaybeSignal<bool>>) -> Self {\r\n        self.hinting = hinting.into();\r\n        self\r\n    }\r\n\r\n    /// Set the font of the text.\r\n    #[inline(always)]\r\n    pub fn with_font(mut self, font: impl Into<MaybeSignal<Option<String>>>) -> Self {\r\n        self.font = font.into();\r\n        self\r\n    }\r\n\r\n    /// Set the font size of the text.\r\n    #[inline(always)]\r\n    pub fn with_font_size(mut self, size: impl Into<MaybeSignal<f32>>) -> Self {\r\n        self.font_size = size.into();\r\n        self\r\n    }\r\n\r\n    /// Set the line gap of the text.\r\n    ///\r\n    /// The line gap is the space between lines of text. Defaults to `7.5`.\r\n    #[inline(always)]\r\n    pub fn with_line_gap(mut self, gap: impl Into<MaybeSignal<f32>>) -> Self {\r\n        self.line_gap = gap.into();\r\n        self\r\n    }\r\n}\r\n\r\nimpl WidgetLayoutExt for Text {\r\n    #[inline(always)]\r\n    fn set_layout_style(&mut self, layout_style: impl Into<MaybeSignal<LayoutStyle>>) {\r\n        self.style = layout_style.into();\r\n    }\r\n}\r\n\r\nimpl Widget for Text {\r\n    fn render(\r\n        &mut self,\r\n        scene: &mut dyn Scene,\r\n        theme: &mut dyn Theme,\r\n        layout_node: &LayoutNode,\r\n        info: &AppInfo,\r\n        _: AppContext,\r\n    ) {\r\n        let font_name = self.font.get();\r\n\r\n        let font = if font_name.is_some() {\r\n            info.font_context\r\n                .get(font_name.deref().clone().unwrap())\r\n                .expect(\"Font not found\")\r\n        } else {\r\n            info.font_context.default_font().clone()\r\n        };\r\n\r\n        let color = if let Some(style) = theme.of(Self::widget_id(self)) {\r\n            if theme.globals().invert_text_color {\r\n                style.get_color(\"color_invert\").unwrap()\r\n            } else {\r\n                style.get_color(\"color\").unwrap()\r\n            }\r\n        } else {\r\n            theme.defaults().text().foreground()\r\n        };\r\n\r\n        if *self.wrap.get() {\r\n            self.max_width = layout_node.layout.size.width;\r\n        } else {\r\n            self.max_width = f32::INFINITY;\r\n        }\r\n\r\n        scene.draw_text(\r\n            &Brush::Solid(color),\r\n            None,\r\n            Vector2::new(layout_node.layout.location.x, layout_node.layout.location.y),\r\n            self.text.get().as_str(),\r\n            *self.hinting.get(),\r\n            &font,\r\n            *self.font_size.get(),\r\n            *self.line_gap.get(),\r\n            self.max_width,\r\n        );\r\n    }\r\n\r\n    fn layout_style(&self) -> StyleNode {\r\n        let text = self.text.get();\r\n\r\n        let font_size = *self.font_size.get();\r\n\r\n        let style = self.style.get().deref().clone();\r\n\r\n        StyleNode {\r\n            style: LayoutStyle {\r\n                size: Vector2::new(\r\n                    Dimension::length(font_size * text.len() as f32),\r\n                    Dimension::length(font_size),\r\n                ),\r\n                ..style\r\n            },\r\n            children: Vec::new(),\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn update(&mut self, layout: &LayoutNode, _: AppContext, _: &AppInfo) -> Update {\r\n        // Re-layout if the maximum width of the text changes.\r\n        if *self.wrap.get() && !layout::equal(layout.layout.size.width, self.max_width) {\r\n            Update::LAYOUT\r\n        } else {\r\n            Update::empty()\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn widget_id(&self) -> WidgetId {\r\n        WidgetId::new(\"maycoon-widgets\", \"Text\")\r\n    }\r\n}\r\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":61},{"path":["C:","\\","Users","Mikail","Desktop","Coding","Projects","Maycoon Coverage","maycoon","src","lib.rs"],"content":"#![warn(missing_docs)]\r\n\r\n//! Create beautiful and lightning fast UI Applications with Rust.\r\n//!\r\n//! See [maycoon-ui.github.io/](https://maycoon-ui.github.io/) for more information.\r\n\r\npub use nalgebra as math;\r\npub use peniko as color;\r\n\r\npub use maycoon_core as core;\r\npub use maycoon_theme as theme;\r\npub use maycoon_widgets as widgets;\r\n\r\n#[cfg(feature = \"macros\")]\r\npub use maycoon_macros as macros;\r\n","traces":[],"covered":0,"coverable":0}],"coverage":10.849315068493151,"covered":198,"coverable":1825}